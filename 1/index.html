<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Halloween One‑Button Game</title>
  <style>
    :root {
      --bg0: #0b0f19;
      --bg1: #0f1330;
      --accent: #ff7a00;
      --accent2: #b66dff;
      --accent3: #c9f;
      --danger: #ff3b30;
      --text: #e9e9f0;
    }

    html, body { height: 100%; margin: 0; background: radial-gradient(120% 120% at 50% 0%, var(--bg1), var(--bg0)); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Arial, Apple Color Emoji, Segoe UI Emoji; overscroll-behavior: none; }

    .wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas { display: block; background: transparent; touch-action: none; }

    /* HUD (점수) */
    .hud { position: fixed; inset: 0; pointer-events: none; }
    .score { position: absolute; top: env(safe-area-inset-top, 12px); left: 12px; padding: 6px 10px; border-radius: 10px; backdrop-filter: blur(6px); background: #0006; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 4px 16px #0007; user-select: none; }
    .hi { margin-left: 8px; opacity: .75; font-weight: 600; }

    /* 정보/설정 버튼 */
    .topbar { position: fixed; top: env(safe-area-inset-top, 12px); right: 12px; display: flex; gap: 8px; pointer-events: auto; z-index: 5; }
    .iconbtn { appearance: none; border: 0; width: 36px; height: 36px; border-radius: 50%; background: radial-gradient(120% 120% at 30% 20%, #7f5cff, #4a2fff); color: #fff; font-size: 18px; font-weight: 900; cursor: pointer; box-shadow: 0 6px 16px #0008, inset 0 0 0 1px #ffffff33; display: grid; place-items: center; }
    .iconbtn:active { transform: translateY(1px); }

    /* 오버레이 */
    .overlay { position: fixed; inset: 0; display: none; place-items: center; background: linear-gradient(180deg, #0008, #0004); backdrop-filter: blur(3px); z-index: 4; }
    .panel { pointer-events: auto; text-align: center; padding: 18px 20px; border-radius: 16px; background: #0c112480; border: 1px solid #ffffff18; box-shadow: 0 10px 30px #0009; max-width: min(90vw, 420px); }
    .title { font-size: 18px; margin-bottom: 10px; font-weight: 800; }
    .sub { opacity: .8; font-size: 13px; margin-bottom: 14px; }
    .btn { margin-top: 6px; appearance: none; border: 0; border-radius: 14px; background: linear-gradient(180deg, var(--accent2), #6a37ff); color: white; padding: 12px 16px; font-weight: 800; letter-spacing: .4px; cursor: pointer; box-shadow: 0 8px 18px #652bff55, inset 0 0 0 1px #ffffff30; }
    .btn:active { transform: translateY(1px); }
    .tips { font-size: 12px; opacity: .75; line-height: 1.4; margin-top: 10px; }

    /* 설정 패널 UI */
    .settings-grid { display: grid; grid-template-columns: auto 1fr auto; gap: 10px 15px; align-items: center; text-align: left; margin: 20px 0; font-size: 13px; }
    .settings-grid label { font-weight: 600; opacity: 0.9; }
    .settings-grid .value { font-weight: 700; color: var(--accent3); min-width: 30px; text-align: right; }
    input[type=range] { width: 100%; height: 6px; background: #0005; border-radius: 3px; cursor: pointer; appearance: none; }
    input[type=range]::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--accent2); border: 2px solid #fff; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="cv" width="360" height="640" aria-label="Halloween game canvas"></canvas>
  </div>

  <div class="hud">
    <div class="score" id="score">점수 0 <span class="hi" id="hi">최고 0</span></div>
  </div>

  <div class="topbar">
    <button class="iconbtn" id="settingsBtn" aria-label="게임 설정">⚙️</button>
    <button class="iconbtn" id="infoBtn" aria-label="게임 정보" style="font-weight: 700; font-size: 16px;">i</button>
  </div>

  <div class="overlay" id="overlay" style="display:grid">
    <div class="panel">
      <div class="title">할로윈 플로팅 위치</div>
      <div class="sub">눌러서 올라가고, 떼면 내려감. 위/아래나 오브젝트에 닿으면 게임 오버.</div>
      <button class="btn" id="startBtn">시작하기 / 탭 유지로 비행</button>
      <div class="tips">PC: 마우스 버튼 또는 Space / ↑ 키 · 모바일: 화면 길게 터치</div>
    </div>
  </div>

  <div class="overlay" id="infoOverlay">
    <div class="panel">
      <div class="title">게임 정보</div>
      <div class="sub">
        <ul style="text-align:left; line-height:1.6; margin:0; padding-left:18px">
          <li>조작: 화면을 누르면 상승, 떼면 하강</li>
          <li>목표: 오른쪽에서 날아오는 호박·사탕·뼈를 피하기</li>
          <li>점수: 생존 시간에 따라 초당 10점 증가, 최고점은 자동 저장</li>
          <li>게임 오버: 화면 위/아래나 오브젝트에 닿으면 종료</li>
        </ul>
      </div>
      <button class="btn" id="infoCloseBtn">닫기</button>
    </div>
  </div>

  <!-- [추가] 설정 오버레이 -->
  <div class="overlay" id="settingsOverlay">
    <div class="panel">
      <div class="title">난이도 설정</div>
      <div class="settings-grid">
        <label for="speedSlider">시작 속도</label>
        <input type="range" id="speedSlider" min="100" max="500" step="10">
        <span class="value" id="speedValue">140</span>

        <label for="accelSlider">속도 증가율</label>
        <input type="range" id="accelSlider" min="5" max="50" step="1">
        <span class="value" id="accelValue">12</span>

        <label for="gapSlider">시작 간격</label>
        <input type="range" id="gapSlider" min="50" max="500" step="10">
        <span class="value" id="gapValue">280</span>

        <label for="gapRateSlider">간격 감소율</label>
        <input type="range" id="gapRateSlider" min="1" max="20" step="0.5">
        <span class="value" id="gapRateValue">4</span>
      </div>
      <button class="btn" id="settingsCloseBtn">저장하고 닫기</button>
    </div>
  </div>

  <script>
  // ==========================
  // Ultra‑Simple Halloween Game
  // ==========================
  
  // 기본 설정값 (수정 가능) -> let으로 변경하여 런타임에 수정 가능하게 함
  let CFG = { 
    W: 360, H: 640, 
    gravity: 1150, thrust: 1450, 
    playerX: 88, playerR: 18, 
    baseSpeed: 140, speedPerSec: 12, 
    spawnBaseGap: 280,
    spawnMinGap: 180,
    gapReductionPerSec: 4,
    safeMargin: 15,
    starCount: 40 
  };

  // DOM 요소 선택
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const infoBtn = document.getElementById('infoBtn');
  const infoOverlay = document.getElementById('infoOverlay');
  const infoCloseBtn = document.getElementById('infoCloseBtn');
  // [추가] 설정 UI 요소 선택
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsOverlay = document.getElementById('settingsOverlay');
  const settingsCloseBtn = document.getElementById('settingsCloseBtn');
  const speedSlider = document.getElementById('speedSlider');
  const speedValue = document.getElementById('speedValue');
  const accelSlider = document.getElementById('accelSlider');
  const accelValue = document.getElementById('accelValue');
  const gapSlider = document.getElementById('gapSlider');
  const gapValue = document.getElementById('gapValue');
  const gapRateSlider = document.getElementById('gapRateSlider');
  const gapRateValue = document.getElementById('gapRateValue');

  let DPR = Math.min(2, window.devicePixelRatio || 1);
  function fit(){ const ar = CFG.W/CFG.H; const vw = window.innerWidth, vh = window.innerHeight; let dw, dh; if (vw/vh > ar){ dh = vh; dw = vh*ar; } else { dw = vw; dh = vw/ar; } cv.style.width = dw+'px'; cv.style.height = dh+'px'; DPR = Math.min(2, window.devicePixelRatio||1); cv.width = Math.floor(CFG.W*DPR); cv.height = Math.floor(CFG.H*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
  window.addEventListener('resize', fit, { passive: true });
  fit();

  let hiScore = Number(localStorage.getItem('hw_hi')||0)||0; hiEl.textContent = `최고 ${hiScore}`;

  let running=false, dead=false, hold=false, resumeAfterPause=false; let tPrev=0, elapsed=0, score=0; let speed=CFG.baseSpeed, spawnMs=1000, spawnAcc=0;
  let lastObstacleType = '';
  const player = { x: CFG.playerX, y: CFG.H*0.5, vy: 0, r: CFG.playerR };
  const obstacles = [];
  const stars = new Array(CFG.starCount).fill(0).map(()=>({ x: Math.random()*CFG.W, y: Math.random()*CFG.H, z: 0.3+Math.random()*0.7 }));

  // [추가] 설정 관련 함수들
  function loadSettings() {
    const savedSettings = localStorage.getItem('hw_settings');
    if (savedSettings) {
      const userSettings = JSON.parse(savedSettings);
      // 저장된 값이 있으면 기본 CFG 객체를 덮어씀
      CFG = { ...CFG, ...userSettings };
    }
  }

  function updateSettingsUI() {
    speedSlider.value = CFG.baseSpeed;
    speedValue.textContent = CFG.baseSpeed;
    accelSlider.value = CFG.speedPerSec;
    accelValue.textContent = CFG.speedPerSec;
    gapSlider.value = CFG.spawnBaseGap;
    gapValue.textContent = CFG.spawnBaseGap;
    gapRateSlider.value = CFG.gapReductionPerSec;
    gapRateValue.textContent = CFG.gapReductionPerSec;
  }
  
  function saveSettings() {
    const userSettings = {
      baseSpeed: parseInt(speedSlider.value),
      speedPerSec: parseInt(accelSlider.value),
      spawnBaseGap: parseInt(gapSlider.value),
      gapReductionPerSec: parseFloat(gapRateSlider.value)
    };
    localStorage.setItem('hw_settings', JSON.stringify(userSettings));
    CFG = { ...CFG, ...userSettings }; // 현재 게임 설정에도 바로 반영
  }

  // 슬라이더 조작 시 숫자 실시간 업데이트
  speedSlider.addEventListener('input', () => speedValue.textContent = speedSlider.value);
  accelSlider.addEventListener('input', () => accelValue.textContent = accelSlider.value);
  gapSlider.addEventListener('input', () => gapValue.textContent = gapSlider.value);
  gapRateSlider.addEventListener('input', () => gapRateValue.textContent = gapRateSlider.value);

  // 입력 핸들러
  function onDown(e){ hold = true; e.preventDefault(); }
  function onUp(){ hold = false; }
  cv.addEventListener('pointerdown', onDown, { passive: false });
  window.addEventListener('pointerup', onUp, { passive: true });
  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.code==='ArrowUp'){ hold=true; e.preventDefault(); } if(!running && (e.code==='Space'||e.code==='ArrowUp'||e.code==='Enter')) start(); }, { passive: false });
  window.addEventListener('keyup', (e)=>{ if(e.code==='Space'||e.code==='ArrowUp') hold=false; }, { passive: true });

  startBtn.addEventListener('click', ()=>start());
  startBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); if(!running) start(); }, { passive: false });
  overlay.addEventListener('click', ()=>{ if(!running) start(); });

  // 정보/설정 패널 열기/닫기
  if(infoBtn) infoBtn.addEventListener('click', openInfo);
  if(infoCloseBtn) infoCloseBtn.addEventListener('click', closeInfo);
  if(settingsBtn) settingsBtn.addEventListener('click', openSettings);
  if(settingsCloseBtn) settingsCloseBtn.addEventListener('click', closeSettings);

  function resetGame(){ 
    running=false; dead=false; hold=false; elapsed=0; score=0; 
    speed=CFG.baseSpeed; 
    spawnMs=(CFG.spawnBaseGap / CFG.baseSpeed) * 1000; 
    spawnAcc=0; 
    obstacles.length=0; 
    lastObstacleType = '';
    player.x=CFG.playerX; player.y=CFG.H*0.5; player.vy=0; 
    scoreEl.textContent = `점수 0 `; scoreEl.appendChild(hiEl); 
  }
  function start(){ resetGame(); running=true; overlay.style.display='none'; tPrev=performance.now(); requestAnimationFrame(loop); }
  function gameOver(){ if(dead) return; dead=true; running=false; if(navigator.vibrate) navigator.vibrate(120); hiScore = Math.max(hiScore, Math.floor(score)); localStorage.setItem('hw_hi', String(hiScore)); hiEl.textContent = `최고 ${hiScore}`; flash(220); overlay.querySelector('.title').textContent='게임 오버'; overlay.querySelector('.sub').textContent = `점수 ${Math.floor(score)} · 최고 ${hiScore}`; startBtn.textContent='다시 시작'; overlay.style.display='grid'; }
  
  function openInfo(){ resumeAfterPause = running && !dead; if(resumeAfterPause) running=false; if(navigator.vibrate) navigator.vibrate(30); infoOverlay.style.display='grid'; }
  function closeInfo(){ infoOverlay.style.display='none'; if(resumeAfterPause && !dead){ running=true; tPrev=performance.now(); requestAnimationFrame(loop); } }
  
  function openSettings() { resumeAfterPause = running && !dead; if(resumeAfterPause) running=false; if(navigator.vibrate) navigator.vibrate(30); settingsOverlay.style.display='grid'; }
  function closeSettings() { saveSettings(); settingsOverlay.style.display='none'; if(resumeAfterPause && !dead){ running=true; tPrev=performance.now(); requestAnimationFrame(loop); } }

  let flashUntil=0; function flash(ms){ flashUntil = performance.now() + ms; }

  function loop(t){ if(!running) return; const dt = Math.min(0.033, (t - tPrev)/1000); tPrev=t; update(dt); draw(t); requestAnimationFrame(loop); }

  function update(dt){
    elapsed += dt;
    speed = CFG.baseSpeed + elapsed * CFG.speedPerSec;
    
    const targetGap = Math.max(CFG.spawnMinGap, CFG.spawnBaseGap - elapsed * CFG.gapReductionPerSec);
    const targetSpawnMs = (targetGap / speed) * 1000;
    spawnMs = (spawnMs * 0.98) + (targetSpawnMs * 0.02);

    const acc = (hold ? -CFG.thrust : CFG.gravity);
    player.vy += acc * dt; player.y += player.vy * dt;
    if (player.y - player.r < 0 || player.y + player.r > CFG.H){ player.y = Math.max(player.r, Math.min(CFG.H - player.r, player.y)); gameOver(); }
    
    spawnAcc += dt*1000; 
    if (spawnAcc >= spawnMs){ 
      spawnAcc=0; 
      const y = CFG.safeMargin + Math.random()*(CFG.H - CFG.safeMargin*2); 
      const r = 14 + Math.random()*10; 
      
      const allTypes = ['pumpkin', 'candy', 'bone'];
      const availableTypes = allTypes.filter(t => t !== lastObstacleType);
      const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
      lastObstacleType = type;
      
      obstacles.push({ x: CFG.W + 40, y, r, type }); 
    }

    for (let i=obstacles.length-1; i>=0; i--){ const o = obstacles[i]; o.x -= speed*dt; const dx=o.x-player.x, dy=o.y-player.y; const rr=(o.r+player.r)*(o.r+player.r); if(dx*dx+dy*dy < rr){ gameOver(); } if(o.x < -50) obstacles.splice(i,1); }
    score += dt*10; scoreEl.childNodes[0].nodeValue = `점수 ${Math.floor(score)} `;
  }

  // GRAPHICS FUNCTIONS...
  function drawPumpkin(o){
    const {x,y,r}=o;
    const grad = ctx.createRadialGradient(x, y, r * 0.2, x, y, r * 1.1);
    grad.addColorStop(0, '#ff9a20'); grad.addColorStop(1, '#e56a00');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.ellipse(x, y, r * 1.1, r, 0, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#c35a0099'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x, y - r); ctx.quadraticCurveTo(x + r * 0.7, y, x, y + r);
    ctx.moveTo(x, y - r); ctx.quadraticCurveTo(x - r * 0.7, y, x, y + r); ctx.stroke();
    ctx.fillStyle = '#6a4a33';
    ctx.beginPath(); ctx.rect(x - r * 0.15, y - r * 1.3, r * 0.3, r * 0.4); ctx.fill();
    ctx.fillStyle = '#ffdd00'; ctx.shadowColor = '#ffdd00'; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.moveTo(x - r * 0.6, y - r * 0.4); ctx.lineTo(x - r * 0.2, y - r * 0.1); ctx.lineTo(x - r * 0.5, y + r * 0.1); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x + r * 0.6, y - r * 0.4); ctx.lineTo(x + r * 0.2, y - r * 0.1); ctx.lineTo(x + r * 0.5, y + r * 0.1); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x - r * 0.5, y + r * 0.4); ctx.lineTo(x - r * 0.2, y + r * 0.6); ctx.lineTo(x + r * 0.2, y + r * 0.6); ctx.lineTo(x + r * 0.5, y + r * 0.4); ctx.closePath(); ctx.fill();
    ctx.shadowBlur = 0;
  }
  function drawCandy(o){
    const {x,y,r}=o;
    const bodyR = r * 1.1;
    ctx.fillStyle = '#8a4fff99';
    ctx.beginPath(); ctx.moveTo(x - bodyR, y); ctx.lineTo(x - bodyR * 1.8, y - bodyR * 0.7); ctx.lineTo(x - bodyR * 1.7, y + bodyR * 0.7); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x + bodyR, y); ctx.lineTo(x + bodyR * 1.8, y - bodyR * 0.7); ctx.lineTo(x + bodyR * 1.7, y + bodyR * 0.7); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = '#ffffff55'; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(x - bodyR * 1.2, y - bodyR*0.3); ctx.lineTo(x - bodyR * 1.6, y + bodyR*0.2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x + bodyR * 1.2, y - bodyR*0.3); ctx.lineTo(x + bodyR * 1.6, y + bodyR*0.2); ctx.stroke();
    ctx.fillStyle = '#7cff4e';
    circle(x, y, bodyR);
    ctx.fillStyle = '#2c1066';
    ctx.beginPath(); ctx.arc(x, y, bodyR, -0.4, 0.4); ctx.lineTo(x + bodyR * Math.cos(0.4) * 0.6, y + bodyR * Math.sin(0.4) * 0.6); ctx.arc(x, y, bodyR * 0.6, 0.4, -0.4, true); ctx.closePath(); ctx.fill();
    ctx.beginPath(); ctx.arc(x, y, bodyR, Math.PI - 0.4, Math.PI + 0.4); ctx.lineTo(x + bodyR * Math.cos(Math.PI + 0.4) * 0.6, y + bodyR * Math.sin(Math.PI + 0.4) * 0.6); ctx.arc(x, y, bodyR * 0.6, Math.PI + 0.4, Math.PI - 0.4, true); ctx.closePath(); ctx.fill();
  }
  function drawBone(o){
    const {x,y,r}=o;
    const shaftW = r * 2.2; const shaftH = r * 0.8; const knobR = r * 0.8;
    const grad = ctx.createLinearGradient(x - shaftW/2, y - knobR, x + shaftW/2, y + knobR);
    grad.addColorStop(0, '#faf0e6');
    grad.addColorStop(1, '#e0d8c8');
    ctx.fillStyle = grad;
    roundRect(x - shaftW/2, y - shaftH/2, shaftW, shaftH, shaftH/2);
    circle(x - shaftW/2, y - shaftH/2, knobR);
    circle(x - shaftW/2, y + shaftH/2, knobR);
    circle(x + shaftW/2, y - shaftH/2, knobR);
    circle(x + shaftW/2, y + shaftH/2, knobR);
    ctx.fillStyle = '#ffffffaa';
    roundRect(x - shaftW*0.4, y - shaftH*0.3, shaftW*0.8, shaftH*0.3, shaftH*0.15);
  }
  function drawWitch(p, t){
    const {x,y,r}=p;
    const bob = Math.sin(t / 200) * 2;
    ctx.fillStyle = '#d4aa70';
    ctx.beginPath(); ctx.ellipse(x + r * 1.4, y + r * 0.5 + bob, r * 1.1, r*0.5, -0.2, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#a0522d';
    ctx.lineWidth = 5; ctx.beginPath(); ctx.moveTo(x - r * 1.6, y + r * 0.3 + bob); ctx.lineTo(x + r * 1.1, y + r * 0.5 + bob); ctx.stroke();
    ctx.fillStyle = '#6a37ff';
    ctx.beginPath();
    ctx.moveTo(x - r * 0.6, y - r * 0.5 + bob);
    ctx.quadraticCurveTo(x - r * 1.5, y + bob, x - r * 0.6, y + r + bob);
    ctx.quadraticCurveTo(x, y + r*0.5 + bob, x - r * 0.6, y - r * 0.5 + bob);
    ctx.fill();
    ctx.fillStyle = '#2c1066';
    ctx.beginPath();
    ctx.arc(x, y + r * 0.1 + bob, r*0.9, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#f0e68c';
    circle(x, y - r*0.5 + bob, r*0.6);
    ctx.fillStyle = '#cc6600';
    ctx.beginPath();
    const hairShiftX = r * 0.3;
    ctx.moveTo(x + r*0.6 - hairShiftX, y - r*0.8 + bob);
    ctx.quadraticCurveTo(x - hairShiftX, y - r*1.2 + bob, x - r*0.7 - hairShiftX, y - r*0.2 + bob);
    ctx.quadraticCurveTo(x - hairShiftX, y - r*0.4 + bob, x + r*0.6 - hairShiftX, y - r*0.8 + bob);
    ctx.fill();
    ctx.fillStyle = '#ff7a00';
    ctx.beginPath();
    ctx.moveTo(x + r*0.6, y - r*0.8 + bob);
    ctx.quadraticCurveTo(x, y - r*1.2 + bob, x - r*0.7, y - r*0.2 + bob);
    ctx.quadraticCurveTo(x, y - r*0.4 + bob, x + r*0.6, y - r*0.8 + bob);
    ctx.fill();
    ctx.fillStyle = '#4b2a9e';
    ctx.beginPath(); ctx.ellipse(x, y - r * 0.8 + bob, r * 1.1, r * 0.35, 0.1, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x - r*0.8, y - r*0.7 + bob); ctx.lineTo(x, y - r * 2.2 + bob); ctx.lineTo(x + r*0.7, y - r*0.7 + bob); ctx.closePath(); ctx.fill();
  }
  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
  function roundRect(x,y,w,h,r){ const rr=Math.min(r, Math.abs(w)/2, Math.abs(h)/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); ctx.fill(); }
  function draw(t){ ctx.clearRect(0,0,CFG.W,CFG.H); for(const s of stars){ s.x -= (speed*0.2*s.z)*(1/60); if(s.x < -2){ s.x = CFG.W + Math.random()*10; s.y = Math.random()*CFG.H; } ctx.fillStyle = `rgba(255,255,255,${0.3 + s.z*0.7})`; ctx.fillRect(s.x, s.y, 1.4 + s.z*1.2, 1.4 + s.z*1.2); } const fog = ctx.createLinearGradient(0, CFG.H*0.6, 0, CFG.H); fog.addColorStop(0,'rgba(120,80,180,0)'); fog.addColorStop(1,'rgba(120,80,180,0.18)'); ctx.fillStyle=fog; ctx.fillRect(0, CFG.H*0.6, CFG.W, CFG.H*0.4); for(const o of obstacles){ if(o.type==='pumpkin') drawPumpkin(o); else if(o.type==='candy') drawCandy(o); else drawBone(o); } drawWitch(player,t); if(performance.now() < flashUntil){ ctx.fillStyle='#ff3b3040'; ctx.fillRect(0,0,CFG.W,CFG.H); } }
  
  // 게임 시작 시 설정 불러오기
  loadSettings();
  updateSettingsUI();
  
  // 첫 화면 그리기
  draw(0);
  </script>
</body>
</html>