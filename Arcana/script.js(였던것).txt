// ===================== Arcana IDE / Runtime – FULL (Milestones A→B→C) =====================
document.addEventListener('DOMContentLoaded', () => {
  // ------- DOM -------
  const codeInputElement  = document.getElementById('codeInput');
  const highlightingPre   = document.getElementById('highlighting-area');
  const highlightingCode  = highlightingPre ? highlightingPre.querySelector('code') : null;
  const lineNumbers       = document.getElementById('line-numbers');
  const outputConsole     = document.getElementById('outputConsole');
  const statusMessage     = document.getElementById('status-message');
  const runIcon           = document.getElementById('run-icon');
  const clearBtn          = document.getElementById('clear-console-btn');
  const sidebar           = document.getElementById('sidebar');
  const resizer           = document.getElementById('resizer');
  const editorWrapper     = document.querySelector('.editor-wrapper');

  /* ---------- Safety: 클릭 anywhere → textarea 포커스 ---------- */
  if (editorWrapper && codeInputElement) {
    editorWrapper.addEventListener('mousedown', () => {
      codeInputElement.focus();
    });
  }

  // ------- Editor helpers -------
  function escapeHtml(str){
    return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

// --- String utils ---
function __titleCase(s){ return String(s).replace(/\w\S*/g, w => w[0].toUpperCase() + w.slice(1).toLowerCase()); }
function __padLeft(s, ch, w){ s=String(s); ch=String(ch||' '); if (ch==='') ch=' '; while(s.length<w) s = ch + s; return s.length>w ? s.slice(-w) : s; }
function __padRight(s, ch, w){ s=String(s); ch=String(ch||' '); if (ch==='') ch=' '; while(s.length<w) s = s + ch; return s.length>w ? s.slice(0,w) : s; }
function __padCenter(s, ch, w){ s=String(s); ch=String(ch||' '); if (ch==='') ch=' '; while(s.length<w){ if ((w - s.length) % 2) s = s + ch; else s = ch + s; } return s.length>w ? s.slice(0,w) : s; }

// --- Array utils ---
function __shuffleInPlace(arr, rand){ for (let i=arr.length-1;i>0;i--){ const j = Math.floor(rand()* (i+1)); [arr[i],arr[j]] = [arr[j],arr[i]]; } }
function __sampleUnique(arr, k, rand){ const a = arr.slice(); __shuffleInPlace(a, rand); return a.slice(0, Math.max(0, Math.min(k, a.length))); }

// --- Number utils ---
function __clamp(x, lo, hi){ return Math.min(hi, Math.max(lo, x)); }
function __mapNumber(x, a1,b1,a2,b2){ const t = (x - a1) / (b1 - a1); return a2 + t * (b2 - a2); }

// --- File/Clipboard (browser) ---
async function __copyToClipboard(txt){ if (navigator.clipboard && navigator.clipboard.writeText){ await navigator.clipboard.writeText(String(txt)); return true; } return false; }
function __saveAs(text, filename){
  const blob = new Blob([String(text)], {type:'text/plain;charset=utf-8'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename;
  document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href), 500);
}

  // (A) Gutter padding based on real width
  function applyGutterPadding() {
    if (!lineNumbers) return;
    const gutter = Math.ceil(lineNumbers.offsetWidth) + 8; // extra spacing
    if (highlightingPre) highlightingPre.style.paddingLeft = gutter + 'px';
    if (codeInputElement)  codeInputElement.style.paddingLeft  = gutter + 'px';
  }

  // (B) Exact typography sync: copy computed style from textarea
  function syncTypographyExact() {
    if (!codeInputElement) return;
    const cs = getComputedStyle(codeInputElement);

    const copyTo = el => {
      if (!el) return;
      el.style.fontFamily    = cs.fontFamily;
      el.style.fontSize      = cs.fontSize;
      el.style.lineHeight    = cs.lineHeight;
      el.style.letterSpacing = cs.letterSpacing;
      el.style.wordSpacing   = cs.wordSpacing;
      el.style.paddingTop    = cs.paddingTop;
      el.style.paddingBottom = cs.paddingBottom;
      el.style.marginTop     = '0';
    };

    if (highlightingPre){
      highlightingPre.style.margin     = '0';
      highlightingPre.style.fontFamily = cs.fontFamily;
      highlightingPre.style.fontSize   = cs.fontSize;
      highlightingPre.style.lineHeight = cs.lineHeight;
      highlightingPre.style.pointerEvents = 'none';
      highlightingPre.style.userSelect = 'none';
      highlightingPre.style.overflow   = 'hidden';
    }
    if (highlightingCode) copyTo(highlightingCode);
    if (lineNumbers)      copyTo(lineNumbers);
  }

  // (C) Line numbers render + padding
  function updateLineNumbers(){
    if (!lineNumbers || !codeInputElement) return;
    const lines = codeInputElement.value.split('\n').length;
    let buf = '';
    for (let i=1;i<=lines;i++) buf += i + '\n';
    lineNumbers.textContent = buf;
    applyGutterPadding();
  }

  // (D) Tokenizer/Highlighter
  // === REPLACE the whole PHRASES array ===
const PHRASES = [
  // multi-word first
  'is greater than','is less than','is at least','is at most','is between',
  'otherwise when','repeat each','for each key','for each','as long as','choose upon',
  'start of day','end of day','by','with','into','ok?','okay?',

  // Arcana commands (readability-tuned)
  'transmute','shear','shearleft','shearright','ascend','descend','crowntitle',
  'begins','ends','chant','carve','countof','fracturelines','bindlines','weave',
  'stir','drawfrom','bindfront','pluckfirst','fuse','unfold','bundle','flood','span',
  'holds','pluck','rebrand','meld','mirror','glyphs','essences','pairs',
  'dawnof','duskof','decodetime','gapdays','gapseconds',
  'remainder','raise','maprange','clamp','round','floor','ceil','abs',
  'now','nowutc','format','summon','invoke','seed','randomfloat','draw','choice','flip','weighteddraw',
  'essenceof','isvoid','encode','decode','indexof','contains',
  'type','tome','seal','set','reveal','listen','prompt','confirm','warn','assert','fail',
  'ward','stride','enumerate','until','guard','when','otherwise','conclude','and','or','not','is','truth','lie',
  'sum','average','min','max','unique','reverse','sort',
  'takefirst','takelast','padleft','padright','padcenter'
].sort((a,b)=>b.length-a.length);

  const WORD_RX = /[A-Za-z_]/;
  const isWord  = ch => WORD_RX.test(ch) || (ch >= '0' && ch <= '9');

  function tokenize(src){
    const t=[]; let i=0, n=src.length;
    const push=(type,txt)=>t.push({type,txt,low:txt.toLowerCase()});
    while(i<n){
      const ch = src[i];

      // newline
      if (ch === '\n'){ push('nl','\n'); i++; continue; }

      // spaces
      if (ch===' '||ch==='\t'){ let j=i+1; while(j<n && (src[j]===' '||src[j]==='\t')) j++; push('ws', src.slice(i,j)); i=j; continue; }

      // comment //
      if (ch==='/' && i+1<n && src[i+1]==='/'){ let j=i+2; while(j<n && src[j] !== '\n') j++; push('comment', src.slice(i,j)); i=j; continue; }

      // triple-quoted string """..."""
      if (ch === '"' && i+2<n && src[i+1]==='"' && src[i+2]==='"'){
        let j=i+3, esc=false;
        while(j<n){
          if (src[j]==='"' && src[j+1]==='"' && src[j+2]==='"'){ j+=3; break; }
          const c=src[j];
          if (esc){ esc=false; j++; continue; }
          if (c==='\\'){ esc=true; j++; continue; }
          j++;
        }
        push('string', src.slice(i,j)); i=j; continue;
      }

      // normal string "..."
      if (ch === '"'){
        let j=i+1, esc=false;
        while(j<n){
          const c=src[j];
          if (esc){ esc=false; j++; continue; }
          if (c==='\\'){ esc=true; j++; continue; }
          if (c=== '"'){ j++; break; }
          j++;
        }
        push('string', src.slice(i,j)); i=j; continue;
      }

      // number (simple)
      if ((ch>='0' && ch<='9') || (ch==='-' && i+1<n && src[i+1]>='0' && src[i+1]<='9')){
        let j=i+1; while(j<n && ((src[j]>='0'&&src[j]<='9')||src[j]==='.' )) j++; push('number', src.slice(i,j)); i=j; continue;
      }

      // keywords
      let matched=false;
      if (!isWord(src[i-1]||' ')) {
        const tail=src.slice(i).toLowerCase();
        for (const kw of PHRASES){
          if (tail.startsWith(kw)){
            const before = src[i-1]||' ';
            const after  = src[i+kw.length]||' ';
            if (!isWord(before) && !isWord(after)){ push('kw', src.substr(i, kw.length)); i+=kw.length; matched=true; break; }
          }
        }
        if (matched) continue;
      }

      // identifier
      if (WORD_RX.test(ch)){ let j=i+1; while(j<n && isWord(src[j])) j++; push('ident', src.slice(i,j)); i=j; continue; }

      // operators & punctuation (include dot/brackets/braces for highlighting)
      if ('+-*/:()[]{}.,'.includes(ch)){ push('op', ch); i++; continue; }

      // fallback single char
      push('ws', ch); i++;
    }
    return t;
  }

  function annotate(tokens){
    let atLineStart=true;
    for(const tk of tokens){
      tk.sol = atLineStart;
      if (tk.type==='nl') atLineStart=true;
      else if (tk.type!=='ws') atLineStart=false;
    }
    // "name is ..." → name 을 변수로 표시
    for (let i=0;i<tokens.length;i++){
      if (tokens[i].type==='ident' && tokens[i].sol){
        let j=i+1; while(j<tokens.length && tokens[j].type==='ws') j++;
        if (j<tokens.length && tokens[j].type==='kw' && tokens[j].low==='is'){ tokens[i].type='var'; }
      }
    }
    // "Set name to ..." → name 을 변수로 표시
    for (let i=0;i<tokens.length;i++){
      if (tokens[i].type==='kw' && tokens[i].low==='set' && tokens[i].sol){
        let j=i+1; while(j<tokens.length && tokens[j].type==='ws') j++;
        if (j<tokens.length && tokens[j].type==='ident'){
          let k=j+1; while(k<tokens.length && tokens[k].type==='ws') k++;
          if (k<tokens.length && tokens[k].type==='kw' && tokens[k].low==='to') tokens[j].type='var';
        }
      }
    }
    return tokens;
  }

  function renderTokens(tokens){
    let html='';
    for (const tk of tokens){
      const txt = escapeHtml(tk.txt);
      switch(tk.type){
        case 'nl': html+='\n'; break;
        case 'ws': html+=txt; break;
        case 'comment': html+=`<span class="tok-comment">${txt}</span>`; break;
        case 'string':  html+=`<span class="tok-string">${txt}</span>`; break;
        case 'number':  html+=`<span class="tok-number">${txt}</span>`; break;
        case 'kw':      html+=`<span class="tok-keyword">${txt}</span>`; break;
        case 'var':     html+=`<span class="tok-variable">${txt}</span>`; break;
        case 'ident':   html+=`<span class="tok-identifier">${txt}</span>`; break;
        case 'op':      html+=`<span class="tok-operator">${txt}</span>`; break;
        default:        html+=txt; break;
      }
    }
    return html;
  }

  function highlightArcana(src){
    return renderTokens(annotate(tokenize(src)));
  }

  // (E) Highlight + scroll sync
  function syncHighlight(){
    if (!highlightingCode) return;
    const src = codeInputElement.value;
    highlightingCode.innerHTML = highlightArcana(src);
    // scroll은 textarea만 주체 → 위치만 따라감
    highlightingPre.scrollTop  = codeInputElement.scrollTop;
    highlightingPre.scrollLeft = codeInputElement.scrollLeft;
  }

  function syncScroll(){
    if (!codeInputElement) return;
    const y = Math.round(codeInputElement.scrollTop);
    const x = Math.round(codeInputElement.scrollLeft);
    if (highlightingPre){
      highlightingPre.scrollTop  = y;
      highlightingPre.scrollLeft = x;
    }
    if (lineNumbers){
      lineNumbers.style.transform = `translate3d(0, ${-y}px, 0)`;
    }
  }

  // Init listeners
  if (codeInputElement && highlightingPre && highlightingCode) {
    syncTypographyExact();        // 폰트/라인높이/패딩 완전 일치
    updateLineNumbers();
    applyGutterPadding();
    syncHighlight();
    syncScroll();

    codeInputElement.addEventListener('input', () => {
      updateLineNumbers();
      syncHighlight();
    });
    codeInputElement.addEventListener('scroll', syncScroll);
    window.addEventListener('resize', () => { applyGutterPadding(); syncTypographyExact(); });
    if (document.fonts && document.fonts.ready) { document.fonts.ready.then(() => { applyGutterPadding(); syncTypographyExact(); }); }
  }

  if (clearBtn) {
    clearBtn.addEventListener('click', () => { outputConsole.textContent = ''; });
  }

  /* ===== Sidebar Resizer (drag + persistence) ===== */
  (function setupSidebarResize(){
    if (!sidebar || !resizer) return;
    // 복원
    const saved = parseInt(localStorage.getItem('arcana.sidebarWidth'), 10);
    if (!isNaN(saved)){
      const clamped = Math.max(220, Math.min(720, saved));
      sidebar.style.setProperty('--sidebar-width', clamped + 'px');
      sidebar.style.width = clamped + 'px';
      sidebar.style.flexBasis = clamped + 'px';
    }
    // 드래그
    let startX=0, startW=0;
    function onPointerDown(e){
      e.preventDefault();
      startX = e.clientX;
      startW = sidebar.getBoundingClientRect().width;
      resizer.classList.add('dragging');
      resizer.setPointerCapture(e.pointerId);
      resizer.addEventListener('pointermove', onPointerMove);
      resizer.addEventListener('pointerup', onPointerUp);
    }
    function onPointerMove(e){
      const dx = e.clientX - startX;
      const mainMin = 300;
      const maxByViewport = Math.max(220, window.innerWidth - mainMin - 48 - 6);
      let w = Math.round(startW + dx);
      w = Math.max(220, Math.min(Math.min(720, maxByViewport), w));
      sidebar.style.setProperty('--sidebar-width', w + 'px');
      sidebar.style.width = w + 'px';
      sidebar.style.flexBasis = w + 'px';
    }
    function onPointerUp(e){
      resizer.classList.remove('dragging');
      resizer.releasePointerCapture(e.pointerId);
      resizer.removeEventListener('pointermove', onPointerMove);
      resizer.removeEventListener('pointerup', onPointerUp);
      const w = sidebar.getBoundingClientRect().width | 0;
      localStorage.setItem('arcana.sidebarWidth', String(w));
    }
    function resetSidebar(){ const def=360;
      sidebar.style.setProperty('--sidebar-width', def + 'px');
      sidebar.style.width = def + 'px';
      sidebar.style.flexBasis = def + 'px';
      localStorage.removeItem('arcana.sidebarWidth');
    }
    resizer.addEventListener('pointerdown', onPointerDown);
    resizer.addEventListener('dblclick', resetSidebar);
  })();

  // ================== Runtime (Interpreter) ==================
  let variables = {};
  let functionsTable = {};
  let constTable = new Set();      // Seal 상수
  let __inFunction = false;
  let output = '';

  // --- RNG (Seed random) ---
  let __seed = null;
  function __rand(){
    if (__seed === null) return Math.random();
    __seed = (__seed * 1664525 + 1013904223) >>> 0;
    return __seed / 4294967296;
  }
  function __setSeed(n){
    const iv = Math.floor(Number(n));
    if (!Number.isFinite(iv)) throw new Error('시드가 유효하지 않습니다.');
    __seed = (iv >>> 0);
  }

  // --- loop control tokens ---
  function __mkBreak(){ const e = new Error('__break'); e.__arcana_break = true; return e; }
  function __mkCont (){ const e = new Error('__continue'); e.__arcana_continue = true; return e; }

  // util: safe comma split
  // === ADD (if missing) under Utils ===
function splitTopLevelByComma(s){
  let arr=[], cur='', depth=0, inS=false, q=null;
  for (let i=0;i<s.length;i++){
    const c=s[i], p=s[i-1];
    if (inS){ cur+=c; if (c===q && p!=='\\'){ inS=false; q=null; } continue; }
    if (c==='"' || c==="'"){ inS=true; q=c; cur+=c; continue; }
    if (c==='['||c==='{'){ depth++; cur+=c; continue; }
    if (c===']'||c==='}'){ depth--; cur+=c; continue; }
    if (c===',' && depth===0){ arr.push(cur.trim()); cur=''; continue; }
    cur+=c;
  }
  if (cur.trim()!=='') arr.push(cur.trim());
  return arr;
}

const __titleCase =(s)=>String(s).replace(/\w\S*/g, w=>w[0].toUpperCase()+w.slice(1).toLowerCase());
const __padLeft  =(s,ch,w)=>{ s=String(s); ch=String(ch||' '); if(ch==='')ch=' '; while(s.length<w)s=ch+s; return s.length>w?s.slice(-w):s; };
const __padRight =(s,ch,w)=>{ s=String(s); ch=String(ch||' '); if(ch==='')ch=' '; while(s.length<w)s=s+ch; return s.length>w?s.slice(0,w):s; };
const __padCenter=(s,ch,w)=>{ s=String(s); ch=String(ch||' '); if(ch==='')ch=' '; while(s.length<w){ if((w-s.length)%2)s=s+ch; else s=ch+s; } return s.length>w?s.slice(0,w):s; };

// Shape(lambda) helpers
function __parseShape(src){
  const s = String(src).trim();
  let m = s.match(/^Shape\s*\(\s*([^)]+?)\s*\)\s*=>\s*([\s\S]+)$/i);
  if (m){ const params=m[1].split(',').map(x=>x.trim()).filter(Boolean); return {__shape:true, params, expr:m[2].trim()}; }
  m = s.match(/^Shape\s+([A-Za-z_]\w*)\s*=>\s*([\s\S]+)$/i);
  if (m){ return {__shape:true, params:[m[1]], expr:m[2].trim()}; }
  return null;
}
const __isShape = v => v && v.__shape===true;
function __execShape(shape, args, variablesRef){
  const saved = variablesRef;
  const local = Object.create(saved);
  (shape.params||[]).forEach((p,i)=>{ local[p] = args[i]; });
  variables = local;
  try{
    return evaluateValue(shape.expr);
  } finally {
    variables = saved;
  }
}



  function stripOuterParens(s){
    const t = s.trim();
    if (!t.startsWith('(') || !t.endsWith(')')) return t;
    let depth = 0;
    for (let i=0;i<t.length;i++){
      const ch = t[i];
      if (ch==='(') depth++;
      else if (ch===')') {
        depth--;
        if (depth===0 && i !== t.length-1) return t; // outer closes before end
      }
    }
    if (depth===0) return stripOuterParens(t.slice(1,-1));
    return t;
  }

  // ----- path parsing for obj/array access: hero.stats.hp / hero["name"] / arr[ i ]
  function parsePath(expr){
    const s = expr.trim();
    const m = s.match(/^([A-Za-z_]\w*)([\s\S]*)$/);
    if (!m) return null;
    const root = m[1];
    let pos = m[1].length;
    const steps = [];
    while (pos < s.length){
      if (/\s/.test(s[pos])) { pos++; continue; }
      if (s[pos] === '.'){
        pos++;
        const m2 = s.slice(pos).match(/^([A-Za-z_]\w*)/);
        if (!m2) return null;
        steps.push({type:'prop', key:m2[1]});
        pos += m2[1].length;
        continue;
      }
      if (s[pos] === '['){
        let j = pos+1, depth=1, inStr=false, esc=false;
        while(j < s.length){
          const c = s[j];
          if (inStr){
            if (esc){ esc=false; j++; continue; }
            if (c==='\\'){ esc=true; j++; continue; }
            if (c === '"') inStr = false;
            j++; continue;
          }
          if (c === '"'){ inStr = true; j++; continue; }
          if (c === '[') depth++;
          else if (c === ']'){ depth--; if (depth===0) break; }
          j++;
        }
        if (j >= s.length) return null;
        const inner = s.slice(pos+1, j);
        steps.push({type:'expr', expr: inner});
        pos = j+1;
        continue;
      }
      // unexpected
      return null;
    }
    return {root, steps};
  }

  function getPathValue(expr){
    const p = parsePath(expr);
    if (!p) return undefined;
    if (!Object.prototype.hasOwnProperty.call(variables, p.root)) throw new Error(`'${p.root}' 변수를 찾을 수 없습니다.`);
    let cur = variables[p.root];
    for (const st of p.steps){
      const key = st.type==='prop' ? st.key : evaluateValue(st.expr);
      if (cur == null) return undefined;
      if (typeof cur === 'string' || Array.isArray(cur)){
        // 배열/문자열 인덱싱
        const idx = (typeof key === 'number') ? key : Number(key);
        if (!Number.isFinite(idx)) throw new Error('인덱스가 숫자가 아닙니다.');
        cur = (typeof cur === 'string') ? cur.charAt(idx) : cur[idx];
      } else {
        cur = cur[key];
      }
    }
    return cur;
  }

  function setPathValue(expr, newVal){
    const p = parsePath(expr);
    if (!p) throw new Error('할당 경로를 해석할 수 없습니다.');
    if (p.steps.length === 0){
      // top-level 변수 재할당
      if (constTable.has(p.root)) throw new Error(`'${p.root}'는 상수(Seal)라서 재할당할 수 없습니다.`);
      variables[p.root] = newVal;
      return;
    }
    if (!Object.prototype.hasOwnProperty.call(variables, p.root)) throw new Error(`'${p.root}' 변수를 찾을 수 없습니다.`);
    let cur = variables[p.root];
    for (let i=0;i<p.steps.length-1;i++){
      const st = p.steps[i];
      const key = st.type==='prop' ? st.key : evaluateValue(st.expr);
      if (cur == null) throw new Error('경로 중간 값이 없습니다.');
      cur = cur[key];
    }
    const last = p.steps[p.steps.length-1];
    const lastKey = last.type==='prop' ? last.key : evaluateValue(last.expr);
    if (cur == null) throw new Error('경로의 대상이 없습니다.');
    cur[lastKey] = newVal;
  }

  // Evaluate expressions
  function evaluateValue(valueString){
    let s = stripOuterParens(valueString);

    // Triple quoted string """..."""
    if (s.startsWith('"""') && s.endsWith('"""')) {
      return s.slice(3,-3).replace(/\r?\n/g, '\n');
    }

    // Shape 람다 리터럴
    const shp = __parseShape(s);
    if (shp) return shp;

    // String
    if (s.startsWith('"') && s.endsWith('"')) {
      return s.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,'\\');
    }

    // Tome { ... }
    if (/^Tome\s*\{[\s\S]*\}$/.test(s)){
      const inner = s.replace(/^Tome\s*\{/, '').replace(/\}$/, '');
      const obj = {};
      const pairs = splitTopLevelByComma(inner);
      for (const entry of pairs){
        // split top-level colon
        let depth=0, inStr=false, esc=false, cut=-1;
        for (let i=0;i<entry.length;i++){
          const c = entry[i];
          if (inStr){
            if (esc){ esc=false; continue; }
            if (c==='\\'){ esc=true; continue; }
            if (c === '"') inStr = false;
            continue;
          }
          if (c === '"'){ inStr=true; continue; }
          if ('[{('.includes(c)) { depth++; continue; }
          if (')]}'.includes(c)) { depth--; continue; }
          if (c === ':' && depth===0){ cut=i; break; }
        }
        if (cut === -1) throw new Error('Tome 구문 오류: key: value 형식이어야 합니다.');
        let keyRaw = entry.slice(0,cut).trim();
        let valRaw = entry.slice(cut+1).trim();
        let key;
        if (keyRaw.startsWith('"') && keyRaw.endsWith('"')) key = keyRaw.slice(1,-1);
        else {
          const km = keyRaw.match(/^[A-Za-z_]\w*$/);
          if (!km) throw new Error('Tome 키는 식별자 또는 문자열이어야 합니다.');
          key = km[0];
        }
        obj[key] = evaluateValue(valRaw);
      }
      return obj;
    }

    // Array
    if (s.startsWith('[') && s.endsWith(']')) {
      return splitTopLevelByComma(s.slice(1,-1)).map(part => evaluateValue(part));
    }

    // Path access: a.b.c / a["k"] / a[i]
    if (/^[A-Za-z_]\w*(?:\s*(?:\.\s*[A-Za-z_]\w*|\[\s*[\s\S]+?\s*\]))+$/.test(s)){
      return getPathValue(s);
    }

    // Indexing simple: name[expr]  (kept for backward compat)
    const mIdx = s.match(/^([A-Za-z_]\w*)\s*\[\s*(.+)\s*\]$/);
    if (mIdx){
      return getPathValue(s);
    }

    // arithmetic parsing helpers (handle unary -)
    function tokenSplitTop(expr, splitOps){
      let parts=[], ops=[], buf='', depth=0, inStr=false, esc=false;
      for (let i=0;i<expr.length;i++){
        const ch=expr[i], prev=expr[i-1];
        if (inStr){
          buf+=ch;
          if (esc){ esc=false; continue; }
          if (ch==='\\'){ esc=true; continue; }
          if (ch === '"') inStr=false;
          continue;
        }
        if (ch === '"'){ inStr=true; buf+=ch; continue; }
        if ('[({'.includes(ch)){ depth++; buf+=ch; continue; }
        if (')]}'.includes(ch)){ depth--; buf+=ch; continue; }
        if (splitOps.includes(ch) && depth===0){
          const isUnary = (ch==='-' && (i===0 || '+-*/(,'.includes(prev)));
          if (!isUnary){ parts.push(buf.trim()); buf=''; ops.push(ch); continue; }
        }
        buf+=ch;
      }
      if (buf.trim().length) parts.push(buf.trim());
      return {parts, ops};
    }

    function evaluateAtom(atom){
      const t = stripOuterParens(atom.trim());
      if (/^-?\d+(\.\d+)?$/.test(t)) return parseFloat(t);
      if (t === 'truth') return true;
      if (t === 'lie')   return false;
      if (t.startsWith('"""') && t.endsWith('"""')) return t.slice(3,-3).replace(/\r?\n/g, '\n');
      if (t.startsWith('"') && t.endsWith('"')) return t.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,'\\');
      if (t.startsWith('[') && t.endsWith(']')) return splitTopLevelByComma(t.slice(1,-1)).map(e=>evaluateValue(e));
      if (/^Tome\s*\{[\s\S]*\}$/.test(t)) return evaluateValue(t); // delegate
      if (Object.prototype.hasOwnProperty.call(variables, t)) return variables[t];
      // dotted path alone
      if (/^[A-Za-z_]\w*(?:\s*(?:\.\s*[A-Za-z_]\w*|\[\s*[\s\S]+?\s*\]))+$/.test(t)) return getPathValue(t);
      if (t !== atom) return evaluateValue(t);
      throw new Error(`'${t}' 값을 해석할 수 없습니다.`);
    }

    // + / -
    const addSub = tokenSplitTop(s, '+-');
    if (addSub.parts.length > 1){
      let val = evaluateValue(addSub.parts[0]);
      for (let i=0;i<addSub.ops.length;i++){
        const right = evaluateValue(addSub.parts[i+1]);
        if (addSub.ops[i] === '+'){
          if (typeof val === 'string' || typeof right === 'string') val = String(val) + String(right);
          else {
            if (typeof val !== 'number' || typeof right !== 'number') throw new Error('덧셈의 피연산자가 유효하지 않습니다.');
            val = val + right;
          }
        } else {
          if (typeof val !== 'number' || typeof right !== 'number') throw new Error('숫자가 아닌 값으로 연산할 수 없습니다.');
          val = val - right;
        }
      }
      return val;
    }
    // * /
    const mulDiv = tokenSplitTop(s, '*/');
    if (mulDiv.parts.length > 1){
      let val = evaluateAtom(mulDiv.parts[0]);
      for (let i=0;i<mulDiv.ops.length;i++){
        const right = evaluateAtom(mulDiv.parts[i+1]);
        if (typeof val !== 'number' || typeof right !== 'number') throw new Error('숫자가 아닌 값으로 연산할 수 없습니다.');
        if (mulDiv.ops[i] === '*') val = val * right;
        else {
          if (right === 0) throw new Error('0으로 나눌 수 없습니다.');
          val = val / right;
        }
      }
      return val;
    }

    // fallback atom
    return evaluateAtom(s);
  }

  function evaluateCondition(conditionString){
    const s = conditionString.replace(/\s+/g,' ').trim();

    // === ADD inside evaluateCondition, before the final return ===

// Begins / Ends
let __msw = s.match(/^Begins\s+(.+)\s+with\s+"([^"]*)"\s*$/i);
if (__msw) return String(evaluateValue(__msw[1])).startsWith(__msw[2]);

let __mew = s.match(/^Ends\s+(.+)\s+with\s+"([^"]*)"\s*$/i);
if (__mew) return String(evaluateValue(__mew[1])).endsWith(__mew[2]);

// Contains (value in string/array)
let __mcv = s.match(/^Contains\s+(.+)\s+in\s+(.+)\s*$/i);
if (__mcv){
  const needle = evaluateValue(__mcv[1]);
  const hay    = evaluateValue(__mcv[2]);
  if (typeof hay === 'string') return String(hay).includes(String(needle));
  if (Array.isArray(hay))      return hay.some(v=>v===needle);
  return false;
}

// Holds key "k" in Tome
let __mhk = s.match(/^Holds\s+key\s+(.+)\s+in\s+(.+)\s*$/i);
if (__mhk){
  const k = evaluateValue(__mhk[1]); const o = evaluateValue(__mhk[2]);
  return !!(o && typeof o==='object' && !Array.isArray(o) && Object.prototype.hasOwnProperty.call(o, k));
}

// Contains (값 버전도 조건식에서 허용)
let mcv = s.match(/^Contains\s+(.+)\s+in\s+(.+)\s*$/i);
if (mcv){
  const needle = evaluateValue(mcv[1].trim());
  const hay    = evaluateValue(mcv[2].trim());
  if (typeof hay === 'string') return String(hay).includes(String(needle));
  if (Array.isArray(hay))      return hay.some(v => v === needle);
  return false;
}

// Contains <needle> in <hay> into <flag>
m = line.match(/^Contains\s+(.+)\s+in\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const needle = evaluateValue(m[1].trim());
  const hay = evaluateValue(m[2].trim());
  if (typeof hay === 'string') variables[m[3]] = String(hay).includes(String(needle));
  else if (Array.isArray(hay)) variables[m[3]] = hay.some(v => v === needle);
  else variables[m[3]] = false;
  return;
}

// SliceText <text> from <start> for <len> into <out>
m = line.match(/^SliceText\s+(.+)\s+from\s+(.+)\s+for\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const txt = String(evaluateValue(m[1].trim()));
  let start = Number(evaluateValue(m[2].trim()));
  const len  = Number(evaluateValue(m[3].trim()));
  const L = txt.length;
  if (!Number.isFinite(start) || !Number.isFinite(len)) throw new Error('SliceText 인자가 유효하지 않습니다.');
  if (start < 0) start = Math.max(0, L + start);
  variables[m[4]] = txt.substr(start, Math.max(0,len|0));
  return;
}

// Pluralize <n> word "<w>" into <text>
m = line.match(/^Pluralize\s+(.+)\s+word\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const n = Number(evaluateValue(m[1].trim()));
  const w = String(evaluateValue(m[2].trim()));
  const isOne = (n===1);
  let plural;
  if (isOne) plural = w;
  else {
    const lower = w.toLowerCase();
    if (/(s|x|z|ch|sh)$/i.test(lower)) plural = w + 'es';
    else if (/[bcdfghjklmnpqrstvwxyz]y$/i.test(lower)) plural = w.slice(0,-1) + 'ies';
    else plural = w + 's';
  }
  variables[m[3]] = `${n} ${plural}`;
  return;
}

// Map <arr> with Shape ... into <out>
m = line.match(/^Map\s+(.+)\s+with\s+(Shape[\s\S]+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const arr = evaluateValue(m[1].trim());
  const shape = evaluateValue(m[2].trim());
  if (!Array.isArray(arr)) throw new Error('Map 대상은 배열이어야 합니다.');
  if (!__isShape(shape)) throw new Error('Map에는 Shape 람다가 필요합니다.');
  const out = [];
  for (let i=0;i<arr.length;i++){
    const v = arr[i];
    // 파라미터 1개면 (x), 2개면 (x, i)
    const args = shape.params.length >= 2 ? [v, i] : [v];
    out.push(__execShape(shape, args));
  }
  variables[m[3]] = out;
  return;
}

// Filter <arr> with Shape ... into <out>
m = line.match(/^Filter\s+(.+)\s+with\s+(Shape[\s\S]+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const arr = evaluateValue(m[1].trim());
  const shape = evaluateValue(m[2].trim());
  if (!Array.isArray(arr)) throw new Error('Filter 대상은 배열이어야 합니다.');
  if (!__isShape(shape)) throw new Error('Filter에는 Shape 람다가 필요합니다.');
  const out = [];
  for (let i=0;i<arr.length;i++){
    const v = arr[i];
    const args = shape.params.length >= 2 ? [v, i] : [v];
    if (__execShape(shape, args)) out.push(v);
  }
  variables[m[3]] = out;
  return;
}

// Reduce <arr> with Shape (acc, x [ ,i ]) => expr from <init> into <out>
m = line.match(/^Reduce\s+(.+)\s+with\s+(Shape[\s\S]+)\s+from\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const arr = evaluateValue(m[1].trim());
  const shape = evaluateValue(m[2].trim());
  let acc = evaluateValue(m[3].trim());
  if (!Array.isArray(arr)) throw new Error('Reduce 대상은 배열이어야 합니다.');
  if (!__isShape(shape)) throw new Error('Reduce에는 Shape 람다가 필요합니다.');
  for (let i=0;i<arr.length;i++){
    const v = arr[i];
    const hasIndex = shape.params.length >= 3;
    const args = hasIndex ? [acc, v, i] : [acc, v];
    acc = __execShape(shape, args);
  }
  variables[m[4]] = acc;
  return;
}


// "<expr> is type <name>"
let mtp = s.match(/^(.+)\s+is\s+type\s+(\w+)\s*$/i);
if (mtp){
  const v = evaluateValue(mtp[1].trim());
  const want = mtp[2].toLowerCase();
  const typ = (v===null||v===undefined) ? 'null'
            : Array.isArray(v) ? 'array'
            : (v instanceof Date) ? 'date'
            : (typeof v === 'object') ? 'tome'
            : typeof v;
  return typ === want;
}

    // Contains X in Y
    let mc = s.match(/^Contains\s+(.+)\s+in\s+(.+)$/i);
    if (mc){
      const val = evaluateValue(mc[1].trim());
      const cont = evaluateValue(mc[2].trim());
      if (typeof cont === 'string') return String(cont).includes(String(val));
      if (Array.isArray(cont)) return cont.some(v => v === val);
      return false;
    }

    // numeric predicates: even/odd/positive/negative/zero
    let mp = s.match(/^(.+)\s+is\s+(even|odd|positive|negative|zero)$/i);
    if (mp){
      const v = Number(evaluateValue(mp[1].trim()));
      if (!Number.isFinite(v)) return false;
      const k = mp[2].toLowerCase();
      if (k==='even') return Math.abs(v % 2) === 0;
      if (k==='odd')  return Math.abs(v % 2) === 1;
      if (k==='positive') return v > 0;
      if (k==='negative') return v < 0;
      if (k==='zero') return v === 0;
    }

    // between A and B
    let mb = s.match(/^(.*)\s+is between\s+(.*)\s+and\s+(.*)$/i);
    if (mb){
      const x = evaluateValue(mb[1].trim());
      const a = evaluateValue(mb[2].trim());
      const b = evaluateValue(mb[3].trim());
      return x >= a && x <= b;
    }

    function cmp(aStr, op, bStr){
      const L = evaluateValue(aStr), R = evaluateValue(bStr);
      switch (op){
        case 'is': return L === R;
        case 'is not': return L !== R;
        case 'is greater than': return L > R;
        case 'is less than': return L < R;
        case 'is at least': return L >= R;
        case 'is at most':  return L <= R;
        default: throw new Error('알 수 없는 비교 연산자: ' + op);
      }
    }

    // split by OR/AND at top-level
    function splitBy(word, text){
      const out=[]; let buf='', depth=0, inStr=false, esc=false;
      const W=' '+word+' ';
      for (let i=0;i<text.length;){
        if (inStr){
          const ch=text[i]; buf+=ch;
          if (esc){ esc=false; i++; continue; }
          if (ch==='\\'){ esc=true; i++; continue; }
          if (ch === '"') inStr=false;
          i++; continue;
        }
        if (text[i] === '"'){ inStr=true; buf+='"'; i++; continue; }
        const ch=text[i];
        if ('[({'.includes(ch)){ depth++; buf+=ch; i++; continue; }
        if (')]}'.includes(ch)){ depth--; buf+=ch; i++; continue; }
        if (depth===0 && text.slice(i,i+W.length).toLowerCase()===W){
          out.push(buf.trim()); buf=''; i+=W.length; continue;
        }
        buf+=ch; i++;
      }
      if (buf.trim().length) out.push(buf.trim());
      return out;
    }

    const orParts = splitBy('or', s);
    if (orParts.length > 1) return orParts.some(p => evaluateCondition(p));
    const andParts = splitBy('and', s);
    if (andParts.length > 1) return andParts.every(p => evaluateCondition(p));
    if (/^not\s+/i.test(s))  return !evaluateCondition(s.replace(/^not\s+/i,''));

    const ops = [' is greater than ', ' is less than ', ' is at least ', ' is at most ', ' is not ', ' is '];
    for (const op of ops){
      const idx = s.toLowerCase().indexOf(op);
      if (idx !== -1){
        const L = s.slice(0, idx).trim();
        const R = s.slice(idx + op.length).trim();
        return cmp(L, op.trim(), R);
      }
    }
    return !!evaluateValue(s);
  }

  function replaceMagicInk(text){
    return text.replace(/\{\|([\s\S]*?)\|\}/g, (_m, inner) => {
      try { return String(evaluateValue(inner.trim())); }
      catch { return ''; }
    });
  }

  // Merge triple-quoted logical line
  function mergeTripleQuote(lines, i){
    let line = lines[i];
    const count = (line.match(/"""/g) || []).length;
    if (count % 2 === 0) return {line, next: i};
    let j = i+1;
    for (; j<lines.length; j++){
      line += '\n' + lines[j];
      const c = (lines[j].match(/"""/g) || []).length;
      if (c % 2 === 1) break; // closing
    }
    return {line, next: j};
  }

  function findBlockEnd(lines, startIndex){
    let depth = 1;
    function isStarter(raw){
      const l = raw.trim().toLowerCase();
      return l.startsWith('when') ||
       l.startsWith('repeat ') ||
       l.startsWith('for each ') ||
       l.startsWith('for each key') ||   // ADD
       l.startsWith('enumerate ') ||     // ADD
       l.startsWith('until ') ||         // ADD
       l.startsWith('guard ') ||         // ADD
       l.startsWith('as long as') ||
       l.startsWith('choose upon ') ||
       l.startsWith('inscribe ') ||
       l.startsWith('attempt') ||
       l.startsWith('repeat each ') ||
       l.startsWith('count ');
    }
    for (let j = startIndex + 1; j < lines.length; j++){
      const {line} = mergeTripleQuote(lines, j);
      const t = line.trim();
      if (!t) continue;
      if (isStarter(t)) depth++;
      if (t.toLowerCase() === 'conclude') depth--;
      if (depth === 0) return j;
    }
    return -1;
  }

  async function executeBlock(blockCode){
    const lines = blockCode.split('\n');
    for (let idx=0; idx<lines.length; idx++){
      let {line, next} = mergeTripleQuote(lines, idx);
      idx = next;
      const t = line.trim();
      if (!t) continue;
      try {
        await processLine(t);
      } catch (e) {
        if (e && (e.__arcana_return || e.__arcana_break || e.__arcana_continue)) throw e;
        else throw e;
      }
    }
  }

  async function __callFunction(name, func, args){
    const saved = variables;
    const local = Object.create(saved);
    (func.params || []).forEach((p, idx) => { if (p) local[p] = args[idx]; });
    variables = local;
    __inFunction = true;
    let retVal = undefined;
    try {
      const lines = func.body.split('\n');
      for (let idx=0; idx<lines.length; idx++){
        let {line, next} = mergeTripleQuote(lines, idx);
        idx = next;
        const t = line.trim();
        if (!t) continue;
        try {
          await processLine(t);
        } catch (e){
          if (e && e.__arcana_return) { retVal = e.value; break; }
          else throw e;
        }
      }
    } finally {
      __inFunction = false;
      variables = saved;
    }
    return retVal;
  }

  // ---------- Modules (Summon std/math, std/text) ----------
  const modules = {};
  function loadStdModule(path, alias){
    const name = alias || path.split('/').pop();
    if (path === 'std/math'){
      modules[name] = {
        sqrt:(x)=>Math.sqrt(Number(x)),
        floor:(x)=>Math.floor(Number(x)),
        ceil:(x)=>Math.ceil(Number(x)),
        round:(x)=>Math.round(Number(x)),
        pow:(a,b)=>Math.pow(Number(a), Number(b)),
        min:(...xs)=>xs.map(Number).reduce((a,b)=>Math.min(a,b), Infinity),
        max:(...xs)=>xs.map(Number).reduce((a,b)=>Math.max(a,b), -Infinity),
        abs:(x)=>Math.abs(Number(x))
      };
    } else if (path === 'std/text'){
      modules[name] = {
        upper:(s)=>String(s).toUpperCase(),
        lower:(s)=>String(s).toLowerCase(),
        trim:(s)=>String(s).trim(),
        replace:(s, find, repl)=>String(s).split(String(find)).join(String(repl)),
        split:(s, sep)=>String(s).split(String(sep)),
        join:(arr, sep)=>Array.isArray(arr) ? arr.join(String(sep)) : String(arr)
      };
    } else if (path === 'std/time'){
  modules[name] = {
    now: ()=>new Date(),
    format:(d, pat)=>{
      d = (d instanceof Date)? d : new Date(d);
      const pad2 = n => String(n).padStart(2,'0');
      const Y=d.getFullYear(), M=pad2(d.getMonth()+1), D=pad2(d.getDate()),
            H=pad2(d.getHours()), m=pad2(d.getMinutes()), S=pad2(d.getSeconds());
      return String(pat).replace(/YYYY/g,Y).replace(/MM/g,M).replace(/DD/g,D).replace(/HH/g,H).replace(/mm/g,m).replace(/ss/g,S);
    },
    parse:(text, fmt)=>{
      const toks=['YYYY','MM','DD','HH','mm','ss']; const map={YYYY:1970,MM:1,DD:1,HH:0,mm:0,ss:0}; let re=fmt;
      toks.forEach(t=>re=re.replace(t,`(\\d{${t==='YYYY'?4:2}})`)); const rx=new RegExp('^'+re+'$'); const m=String(text).match(rx);
      if(!m) throw new Error('std/time.parse 실패');
      let idx=1; toks.forEach(t=>{ if(fmt.indexOf(t)!==-1) map[t]=parseInt(m[idx++],10); });
      return new Date(map.YYYY, map.MM-1, map.DD, map.HH, map.mm, map.ss);
    },
    addDays:(d,n)=>{ d=new Date(d); const u=new Date(d); u.setDate(u.getDate()+Number(n)); return u; },
    addHours:(d,n)=>{ d=new Date(d); const u=new Date(d); u.setHours(u.getHours()+Number(n)); return u; },
    diffDays:(a,b)=>Math.round((new Date(b)-new Date(a))/86400000),
    diffSeconds:(a,b)=>Math.round((new Date(b)-new Date(a))/1000),
    startOfDay:(d)=>{ d=new Date(d); const u=new Date(d); u.setHours(0,0,0,0); return u; },
    endOfDay:(d)=>{ d=new Date(d); const u=new Date(d); u.setHours(23,59,59,999); return u; }
  };
} else if (path === 'std/json'){
  modules[name] = {
    encode:(v)=>JSON.stringify(v),
    decode:(s)=>JSON.parse(String(s))
  };
} else if (path === 'std/random'){
  modules[name] = {
    seed:(n)=>{ __seed = (Math.floor(Number(n))>>>0); return __seed; },
    float:(a,b)=>{ a=Number(a); b=Number(b); const lo=Math.min(a,b), hi=Math.max(a,b); return __rand()*(hi-lo)+lo; },
    int:(a,b)=>{ a=Number(a); b=Number(b); const lo=Math.min(a,b), hi=Math.max(a,b); return Math.floor(__rand()*(hi-lo+1))+lo; },
    bernoulli:(p)=>{ p=Number(p); if(!(p>=0 && p<=1)) throw new Error('p는 0~1'); return __rand()<p; },
    choice:(...xs)=>{ const arr = xs.length===1 && Array.isArray(xs[0]) ? xs[0] : xs; if(!arr.length) throw new Error('choice 비어있음'); return arr[Math.floor(__rand()*arr.length)]; },
    shuffle:(arr)=>{ if(!Array.isArray(arr)) throw new Error('shuffle 배열 필요'); const a=arr.slice(); __shuffleInPlace(a,__rand); return a; },
    sample:(arr,k)=>{ if(!Array.isArray(arr)) throw new Error('sample 배열 필요'); return __sampleUnique(arr, Number(k)|0, __rand); }
  };
} else if (path === 'std/array'){
  modules[name] = {
    chunk:(arr,size)=>{ if(!Array.isArray(arr)) throw new Error('chunk 배열 필요'); size=Math.max(1,Number(size)|0); const out=[]; for(let i=0;i<arr.length;i+=size) out.push(arr.slice(i,i+size)); return out; },
    flatten:(arr)=>{ if(!Array.isArray(arr)) throw new Error('flatten 배열 필요'); return arr.reduce((a,x)=>a.concat(x),[]); },
    sum:(arr)=>{ if(!Array.isArray(arr)) throw new Error('sum 배열 필요'); return arr.reduce((s,x)=>s+Number(x||0),0); },
    average:(arr)=>{ if(!Array.isArray(arr)) throw new Error('average 배열 필요'); return arr.length? arr.reduce((s,x)=>s+Number(x||0),0)/arr.length : 0; },
    min:(arr)=>{ if(!Array.isArray(arr)||!arr.length) throw new Error('min 배열 필요'); return Math.min(...arr.map(Number)); },
    max:(arr)=>{ if(!Array.isArray(arr)||!arr.length) throw new Error('max 배열 필요'); return Math.max(...arr.map(Number)); },
    unique:(arr)=>Array.from(new Set(arr)),
    concat:(a,b)=>{ if(!Array.isArray(a)||!Array.isArray(b)) throw new Error('concat 배열 2개 필요'); return a.concat(b); }
  };
} else if (path === 'std/tome'){
  modules[name] = {
    keys:(o)=>Object.keys(o||{}),
    values:(o)=>Object.values(o||{}),
    pairs:(o)=>Object.entries(o||{}),
    merge:(a,b)=>Object.assign({}, b||{}, a||{}), // b에 a 덮어쓴 결과 반환(불변)
    tally:(arr)=>{ const f={}; (arr||[]).forEach(x=>{ const k=String(x); f[k]=(f[k]||0)+1; }); return f; }
  };
 } else {
      throw new Error(`알 수 없는 모듈: ${path}`);
    }
  }

  function resolveCallable(name){
    if (name.includes('.')){
      const [ns, fn] = name.split('.');
      const mod = modules[ns];
      if (!mod || typeof mod[fn] !== 'function') throw new Error(`모듈 함수 '${name}'를 찾을 수 없습니다.`);
      return mod[fn];
    }
    const fn = functionsTable[name];
    if (!fn) throw new Error(`함수 '${name}'를 찾을 수 없습니다.`);
    return fn;
  }

  // Single line statements
  async function processLine(line){
    // Escape / Skip
    if (/^Escape\s*(ok\??|okay\??)$/i.test(line)) { throw __mkBreak(); }
    if (/^Skip\s*(ok\??|okay\??)$/i.test(line))   { throw __mkCont(); }

    // Seal (constant)
    let m = line.match(/^Seal\s+(\w+)\s+is\s+([\s\S]+)\s*(ok\??|okay\??)$/i);
    if (m){
      const name = m[1];
      if (Object.prototype.hasOwnProperty.call(variables, name)) throw new Error(`'${name}'는 이미 존재합니다.`);
      variables[name] = evaluateValue(m[2].trim());
      constTable.add(name);
      return;
    }

    // Trace
    if (line.startsWith('Trace:')) {
      const m2 = line.match(/^Trace:\s*"(.*)"\s*(ok\??|okay\??)$/i);
      if (!m2) throw new Error('잘못된 Trace 문법입니다.');
      output += replaceMagicInk(m2[1]) + '\n';
      return;
    }

    // bestow (return)
    m = line.match(/^bestow\s+(.+)\s*(ok\??|okay\??)$/i);
    if (m) {
      const val = evaluateValue(m[1].trim());
      if (!__inFunction) throw new Error('bestow는 함수 내부에서만 사용할 수 있습니다.');
      const ret = new Error('__return');
      ret.__arcana_return = true;
      ret.value = val;
      throw ret;
    }

    // Transmute
    m = line.match(/^Transmute\s+(.+)\s+as\s+(number|string|boolean)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const expr = evaluateValue(m[1].trim());
      const typ  = m[2].toLowerCase();
      const name = m[3];
      let v;
      if (typ==='number'){ v = Number(expr); if (!Number.isFinite(v)) throw new Error('숫자로 변환할 수 없습니다.'); }
      else if (typ==='string'){ v = String(expr); }
      else { v = !!expr; }
      variables[name] = v;
      return;
    }

    // Measure
    m = line.match(/^Measure\s+words\s+of\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const txt = String(evaluateValue(m[1].trim()));
      variables[m[2]] = txt.trim() ? txt.trim().split(/\s+/).length : 0;
      return;
    }
    m = line.match(/^Measure\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const v = evaluateValue(m[1].trim());
      if (typeof v === 'string' || Array.isArray(v)) { variables[m[2]] = v.length; }
      else throw new Error('Measure는 문자열/배열만 지원합니다.');
      return;
    }

    // Split / Join
    m = line.match(/^Split\s+(.+)\s+by\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const s = String(evaluateValue(m[1].trim()));
      const sep = String(evaluateValue(m[2].trim()));
      variables[m[3]] = s.split(sep);
      return;
    }
    m = line.match(/^Join\s+(.+)\s+with\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const arr = evaluateValue(m[1].trim());
      const sep = String(evaluateValue(m[2].trim()));
      if (!Array.isArray(arr)) throw new Error('Join의 대상은 배열이어야 합니다.');
      variables[m[3]] = arr.join(sep);
      return;
    }

    // Seed random
    m = line.match(/^Seed\s+random\s+with\s+(.+)\s*(ok\??|okay\??)$/i);
    if (m){ __setSeed(evaluateValue(m[1].trim())); return; }

    // Reveal
    if (line.startsWith('Reveal:')){
      const match = line.match(/^Reveal:\s*"(.*)"\s*(ok\??|okay\??)$/i);
      if (!match) throw new Error('잘못된 Reveal 문법입니다.');
      output += replaceMagicInk(match[1]) + '\n';
      return;
    }

    // Ensure
    const ensureMatch = line.match(/^Ensure\s+(.+)\s*(ok\??|okay\??)$/i);
    if (ensureMatch){
      if (!evaluateCondition(ensureMatch[1].trim())) throw new Error(`Ensure failed: ${ensureMatch[1].trim()}`);
      return;
    }

    // Wait
    const waitMatch = line.match(/^Wait\s+for\s+([\d.]+)\s*(milliseconds?|ms|seconds?)\s*(ok\??|okay\??)$/i);
    if (waitMatch){
      const num = parseFloat(waitMatch[1]);
      const unit = waitMatch[2].toLowerCase();
      let ms = num;
      if (unit.startsWith('second')) ms = num * 1000;
      await new Promise(r => setTimeout(r, ms));
      return;
    }

    // Listen
    m = line.match(/^Listen\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const ans = window.prompt('Listen:');
      variables[m[1]] = ans;
      return;
    }
    m = line.match(/^Listen\s+"(.*)"\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const ans = window.prompt(m[1]);
      variables[m[2]] = ans;
      return;
    }
    m = line.match(/^Listen\s+number\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const ans = window.prompt('Enter number:');
      const n = parseFloat(ans);
      if (!Number.isFinite(n)) throw new Error('숫자 입력이 필요합니다.');
      variables[m[1]] = n;
      return;
    }

    // Draw (uses seeded RNG if set)
    m = line.match(/^Draw\s+number\s+between\s+(.+)\s+and\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const a = Number(evaluateValue(m[1].trim()));
      const b = Number(evaluateValue(m[2].trim()));
      if (!Number.isFinite(a) || !Number.isFinite(b)) throw new Error('Draw 범위가 숫자가 아닙니다.');
      const lo = Math.min(a,b), hi = Math.max(a,b);
      const val = Math.floor(__rand() * (hi - lo + 1)) + lo;
      variables[m[3]] = val;
      return;
    }
    m = line.match(/^Draw\s+from\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const items = splitTopLevelByComma(m[1].trim()).map(x=>{
        const t=x.trim();
        if (t.startsWith('"') && t.endsWith('"')) return t.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,'\\');
        const n = Number(evaluateValue(t));
        if (!Number.isFinite(n)) throw new Error('Draw 목록 항목이 유효하지 않습니다: ' + t);
        return n;
      });
      if (!items.length) throw new Error('Draw 목록이 비어 있습니다.');
      const idx = Math.floor(__rand()*items.length);
      variables[m[2]] = items[idx];
      return;
    }

    // Array utilities: Append / Pop last / Insert / Remove
    m = line.match(/^Append\s+(.+)\s+to\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const val = evaluateValue(m[1].trim());
      const name = m[2];
      if (!Array.isArray(variables[name])) throw new Error(`'${name}'는 배열이 아닙니다.`);
      variables[name].push(val);
      return;
    }
    m = line.match(/^Pop\s+last\s+from\s+(\w+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const src = m[1], dst = m[2];
      if (!Array.isArray(variables[src])) throw new Error(`'${src}'는 배열이 아닙니다.`);
      variables[dst] = variables[src].pop();
      return;
    }
    m = line.match(/^Insert\s+(.+)\s+into\s+(\w+)\s+at\s+(.+)\s*(ok\??|okay\??)$/i);
    if (m){
      const val = evaluateValue(m[1].trim());
      const arrName = m[2];
      let idx = Number(evaluateValue(m[3].trim()));
      if (!Array.isArray(variables[arrName])) throw new Error(`'${arrName}'는 배열이 아닙니다.`);
      if (!Number.isInteger(idx) || idx < 0 || idx > variables[arrName].length) throw new Error('Insert 인덱스가 범위를 벗어났습니다.');
      variables[arrName].splice(idx, 0, val);
      return;
    }
    m = line.match(/^Remove\s+(.+)\s+from\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const val = evaluateValue(m[1].trim());
      const arrName = m[2];
      if (!Array.isArray(variables[arrName])) throw new Error(`'${arrName}'는 배열이 아닙니다.`);
      const idx = variables[arrName].indexOf(val);
      if (idx !== -1) variables[arrName].splice(idx, 1);
      return;
    }

    // Array tools: IndexOf / Reverse / Unique / Sort
    // IndexOf <value> in <container> into <dst> ok?
m = line.match(/^IndexOf\s+(.+)\s+in\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const val = evaluateValue(m[1].trim());
  const container = evaluateValue(m[2].trim());
  const dst = m[3];
  if (typeof container === 'string'){
    variables[dst] = container.indexOf(String(val));
  } else if (Array.isArray(container)){
    variables[dst] = container.indexOf(val);
  } else {
    throw new Error('IndexOf 대상은 문자열/배열이어야 합니다.');
  }
  return;
}

    // Reverse <array> ok?
m = line.match(/^Reverse\s+(.+)\s*(ok\??|okay\??)$/i);
if (m){
  const arr = evaluateValue(m[1].trim());
  if (!Array.isArray(arr)) throw new Error('Reverse 대상은 배열이어야 합니다.');
  arr.reverse();
  return;
}

    // Unique <array> into <dst> ok?
m = line.match(/^Unique\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const arr = evaluateValue(m[1].trim());
  if (!Array.isArray(arr)) throw new Error('Unique 대상은 배열이어야 합니다.');
  variables[m[2]] = Array.from(new Set(arr));
  return;
}

    m = line.match(/^Sort\s+(.+?)(?:\s+(ascending|descending))?\s*(ok\??|okay\??)$/i);
if (m){
  const arr = evaluateValue(m[1].trim());
  const dir = (m[2]||'ascending').toLowerCase();
  if (!Array.isArray(arr)) throw new Error('Sort 대상은 배열이어야 합니다.');
  const asc = (dir !== 'descending');
  arr.sort((x,y)=>{
    const sx = typeof x, sy = typeof y;
    if (sx==='number' && sy==='number') return asc ? x-y : y-x;
    return asc ? String(x).localeCompare(String(y)) : String(y).localeCompare(String(x));
  });
  return;
}

    // Take slice with end/negative indices
    m = line.match(/^Take\s+(.+?)\s+from\s+(.+?)\s+to\s+(.+?)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const src = evaluateValue(m[1].trim());   // 문자열 또는 배열
      const dst = m[4];
      const len = (typeof src === 'string' || Array.isArray(src)) ? src.length : undefined;
      if (len === undefined) throw new Error('Take는 문자열/배열에서만 사용할 수 있습니다.');

      function norm(expr){
        const txt = String(expr).trim();
        if (/^end$/i.test(txt)) return len;
        const v = Number(evaluateValue(txt));
        if (!Number.isFinite(v)) return 0;
        let idx = Math.trunc(v);
        if (idx < 0) idx = len + idx;
        idx = Math.max(0, Math.min(len, idx));
        return idx;
      }
      let a = norm(m[2]);
      let b = norm(m[3]);
      if (a > b) { const t = a; a = b; b = t; }

      variables[dst] = (typeof src === 'string') ? src.substring(a, b) : src.slice(a, b);
      return;
    }

    // Now / Format
    m = line.match(/^Now\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){ variables[m[1]] = new Date(); return; }
    m = line.match(/^Format\s+(.+)\s+as\s+"([^"]+)"\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      let d = evaluateValue(m[1].trim());
      if (!(d instanceof Date)){
        if (typeof d === 'number') d = new Date(d);
        else d = new Date(String(d));
      }
      const pat = m[2];
      const pad2 = n => String(n).padStart(2,'0');
      const Y = d.getFullYear();
      const M = pad2(d.getMonth()+1);
      const D = pad2(d.getDate());
      const H = pad2(d.getHours());
      const m2= pad2(d.getMinutes());
      const S = pad2(d.getSeconds());
      let out = pat
        .replace(/YYYY/g, String(Y))
        .replace(/MM/g, M)
        .replace(/DD/g, D)
        .replace(/HH/g, H)
        .replace(/mm/g, m2)
        .replace(/ss/g, S);
      variables[m[3]] = out;
      return;
    }

    // Summon module
    m = line.match(/^Summon\s+"([^"]+)"(?:\s+as\s+(\w+))?\s*(ok\??|okay\??)$/i);
    if (m){ loadStdModule(m[1], m[2]); return; }

    // Function call (dotted allowed for modules)
    m = line.match(/^invoke\s+([A-Za-z_]\w*(?:\.[A-Za-z_]\w*)?)\s+with\s*(.*)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
    if (m){
      const fname = m[1];
      const argsRaw = m[2].trim();
      const into = m[3];
      if (fname.includes('.')){
        const fn = resolveCallable(fname);
        const args = argsRaw.length ? splitTopLevelByComma(argsRaw).map(e=>evaluateValue(e)) : [];
        variables[into] = fn(...args);
      } else {
        const func = functionsTable[fname];
        if (!func) throw new Error(`함수 '${fname}'를 찾을 수 없습니다.`);
        const args = argsRaw.length ? splitTopLevelByComma(argsRaw).map(e=>evaluateValue(e)) : [];
        const val = await __callFunction(fname, func, args);
        variables[into] = val;
      }
      return;
    }

    // Declarations / Set (path-aware)
    let decl = line.match(/^(\w+)\s+is\s+([\s\S]+)\s*(ok\??|okay\??)$/i);
    if (decl){
      const name = decl[1];
      if (constTable.has(name)) throw new Error(`'${name}'는 상수(Seal)라서 재할당할 수 없습니다.`);
      variables[name] = evaluateValue(decl[2].trim());
      return;
    }
    const setm = line.match(/^Set\s+(.+?)\s+to\s+(.+)\s*(ok\??|okay\??)$/i);
    if (setm){
      const path = setm[1].trim();
      const val = evaluateValue(setm[2].trim());
      const simple = path.match(/^\w+$/);
      if (simple){
        const name = simple[0];
        if (constTable.has(name)) throw new Error(`'${name}'는 상수(Seal)라서 재할당할 수 없습니다.`);
        if (!Object.prototype.hasOwnProperty.call(variables, name)) throw new Error(`'${name}' 변수를 찾을 수 없습니다.`);
        variables[name] = val;
      } else {
        setPathValue(path, val);
      }
      return;
    }

    /* ---------- 문자열(Text) ---------- */
// Replace "<old>" in <text> with "<new>" into out
m = line.match(/^Replace\s+(.+)\s+in\s+(.+)\s+with\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const oldv = String(evaluateValue(m[1].trim()));
  const src  = String(evaluateValue(m[2].trim()));
  const newv = String(evaluateValue(m[3].trim()));
  variables[m[4]] = src.split(oldv).join(newv);
  return;
}
// Trim / TrimLeft / TrimRight
m = line.match(/^Trim\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = String(evaluateValue(m[1].trim())).trim(); return; }
m = line.match(/^TrimLeft\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = String(evaluateValue(m[1].trim())).replace(/^\s+/, ''); return; }
m = line.match(/^TrimRight\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = String(evaluateValue(m[1].trim())).replace(/\s+$/, ''); return; }
// Upper / Lower / TitleCase
m = line.match(/^Upper\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = String(evaluateValue(m[1].trim())).toUpperCase(); return; }
m = line.match(/^Lower\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = String(evaluateValue(m[1].trim())).toLowerCase(); return; }
m = line.match(/^TitleCase\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = __titleCase(evaluateValue(m[1].trim())); return; }
// StartsWith / EndsWith (값으로)
m = line.match(/^StartsWith\s+(.+)\s+"([^"]*)"\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[3]] = String(evaluateValue(m[1].trim())).startsWith(m[2]); return; }
m = line.match(/^EndsWith\s+(.+)\s+"([^"]*)"\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[3]] = String(evaluateValue(m[1].trim())).endsWith(m[2]); return; }
// PadLeft / PadRight / PadCenter
m = line.match(/^PadLeft\s+(.+)\s+with\s+(.+)\s+to\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[4]] = __padLeft(evaluateValue(m[1].trim()), evaluateValue(m[2].trim()), Number(evaluateValue(m[3].trim()))|0); return; }
m = line.match(/^PadRight\s+(.+)\s+with\s+(.+)\s+to\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[4]] = __padRight(evaluateValue(m[1].trim()), evaluateValue(m[2].trim()), Number(evaluateValue(m[3].trim()))|0); return; }
m = line.match(/^PadCenter\s+(.+)\s+with\s+(.+)\s+to\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[4]] = __padCenter(evaluateValue(m[1].trim()), evaluateValue(m[2].trim()), Number(evaluateValue(m[3].trim()))|0); return; }
// RepeatText "<s>" times n
m = line.match(/^RepeatText\s+(.+)\s+times\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const s = String(evaluateValue(m[1].trim())); const n = Math.max(0, Number(evaluateValue(m[2].trim()))|0);
  variables[m[3]] = s.repeat(n); return;
}
// Count "<substr>" in <text>
m = line.match(/^Count\s+(.+)\s+in\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const needle = String(evaluateValue(m[1].trim())); const hay = String(evaluateValue(m[2].trim()));
  if (needle===''){ variables[m[3]] = 0; return; }
  let c=0, pos=0; while(true){ const i = hay.indexOf(needle, pos); if (i===-1) break; c++; pos = i + needle.length; }
  variables[m[3]] = c; return;
}
// SplitLines / JoinLines
m = line.match(/^SplitLines\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = String(evaluateValue(m[1].trim())).split(/\r?\n/); return; }
m = line.match(/^JoinLines\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const arr = evaluateValue(m[1].trim()); if (!Array.isArray(arr)) throw new Error('JoinLines 대상은 배열이어야 합니다.');
  variables[m[2]] = arr.join('\n'); return;
}
// Interleave <arr> with "<sep>" into <text>
m = line.match(/^Interleave\s+(.+)\s+with\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const arr = evaluateValue(m[1].trim()); const sep = String(evaluateValue(m[2].trim()));
  if (!Array.isArray(arr)) throw new Error('Interleave 대상은 배열이어야 합니다.');
  variables[m[3]] = arr.join(sep); return; }
// Compare <a> with <b>
m = line.match(/^Compare\s+(.+)\s+with\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const A = evaluateValue(m[1].trim()), B = evaluateValue(m[2].trim());
  let r;
  if (typeof A==='number' && typeof B==='number') r = A<B?-1:A>B?1:0;
  else r = String(A).localeCompare(String(B));
  variables[m[3]] = Math.sign(r); return;
}

/* ---------- 배열(Arrays) ---------- */
// Shuffle <arr>
m = line.match(/^Shuffle\s+(.+)\s*(ok\??|okay\??)$/i);
if (m){ const arr = evaluateValue(m[1].trim()); if (!Array.isArray(arr)) throw new Error('Shuffle 대상은 배열이어야 합니다.'); __shuffleInPlace(arr, __rand); return; }
// Sample <arr> count n
m = line.match(/^Sample\s+(.+)\s+count\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const arr = evaluateValue(m[1].trim()); const k = Number(evaluateValue(m[2].trim()))|0;
  if (!Array.isArray(arr)) throw new Error('Sample 대상은 배열이어야 합니다.');
  variables[m[3]] = __sampleUnique(arr, k, __rand); return; }
// Prepend v to arr
m = line.match(/^Prepend\s+(.+)\s+to\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const v = evaluateValue(m[1].trim()); const name = m[2];
  if (!Array.isArray(variables[name])) throw new Error(`'${name}'는 배열이 아닙니다.`); variables[name].unshift(v); return; }
// Shift first from arr into x
m = line.match(/^Shift\s+first\s+from\s+(\w+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a = variables[m[1]]; if (!Array.isArray(a)) throw new Error('Shift 대상은 배열이어야 합니다.'); variables[m[2]] = a.shift(); return; }
// Concat a and b into out
m = line.match(/^Concat\s+(.+)\s+and\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const A = evaluateValue(m[1].trim()); const B = evaluateValue(m[2].trim());
  if (!Array.isArray(A) || !Array.isArray(B)) throw new Error('Concat 대상은 배열 두 개여야 합니다.'); variables[m[3]] = A.concat(B); return; }
// Flatten arr one level
m = line.match(/^Flatten\s+(.+)\s+one\s+level\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const A = evaluateValue(m[1].trim()); if (!Array.isArray(A)) throw new Error('Flatten 대상은 배열이어야 합니다.');
  variables[m[2]] = A.reduce((acc,x)=>acc.concat(x), []); return; }
// TakeFirst n from arr / TakeLast n from arr
m = line.match(/^TakeFirst\s+(.+)\s+from\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const n = Math.max(0, Number(evaluateValue(m[1].trim()))|0); const a = evaluateValue(m[2].trim()); if (!Array.isArray(a)) throw new Error('TakeFirst 대상은 배열이어야 합니다.'); variables[m[3]] = a.slice(0,n); return; }
m = line.match(/^TakeLast\s+(.+)\s+from\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const n = Math.max(0, Number(evaluateValue(m[1].trim()))|0); const a = evaluateValue(m[2].trim()); if (!Array.isArray(a)) throw new Error('TakeLast 대상은 배열이어야 합니다.'); variables[m[3]] = a.slice(Math.max(0, a.length-n)); return; }
// Chunk arr by size
m = line.match(/^Chunk\s+(.+)\s+by\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a = evaluateValue(m[1].trim()); const s = Math.max(1, Number(evaluateValue(m[2].trim()))|0);
  if (!Array.isArray(a)) throw new Error('Chunk 대상은 배열이어야 합니다.');
  const out=[]; for (let i=0;i<a.length;i+=s) out.push(a.slice(i,i+s)); variables[m[3]] = out; return; }
// Sum / Average / Min / Max
m = line.match(/^Sum\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a = evaluateValue(m[1].trim()); if (!Array.isArray(a)) throw new Error('Sum 대상은 배열이어야 합니다.'); variables[m[2]] = a.reduce((s,x)=>s+Number(x||0),0); return; }
m = line.match(/^Average\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a = evaluateValue(m[1].trim()); if (!Array.isArray(a) || a.length===0) { variables[m[2]] = 0; return; } variables[m[2]] = a.reduce((s,x)=>s+Number(x||0),0)/a.length; return; }
m = line.match(/^Min\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a = evaluateValue(m[1].trim()); if (!Array.isArray(a) || a.length===0) throw new Error('Min 대상 배열이 비어 있습니다.'); variables[m[2]] = Math.min(...a.map(Number)); return; }
m = line.match(/^Max\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a = evaluateValue(m[1].trim()); if (!Array.isArray(a) || a.length===0) throw new Error('Max 대상 배열이 비어 있습니다.'); variables[m[2]] = Math.max(...a.map(Number)); return; }
// Fill <arr> with <value>
m = line.match(/^Fill\s+(\w+)\s+with\s+(.+)\s*(ok\??|okay\??)$/i);
if (m){ const name = m[1]; const v = evaluateValue(m[2].trim()); if (!Array.isArray(variables[name])) throw new Error(`'${name}'는 배열이 아닙니다.`); variables[name].fill(v); return; }
// Range start to end by step into arr
m = line.match(/^Range\s+(.+)\s+to\s+(.+)(?:\s+by\s+(.+))?\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const a = Number(evaluateValue(m[1].trim())), b = Number(evaluateValue(m[2].trim()));
  let step = m[3] ? Number(evaluateValue(m[3].trim())) : (a<=b?1:-1);
  if (!Number.isFinite(a)||!Number.isFinite(b)||!Number.isFinite(step)||step===0) throw new Error('Range 파라미터가 유효하지 않습니다.');
  const out=[]; if (step>0){ for (let x=a; x<=b; x+=step) out.push(x); } else { for (let x=a; x>=b; x+=step) out.push(x); }
  variables[m[4]] = out; return;
}

/* ---------- Tome(객체) ---------- */
// Has key "<k>" in hero into flag
m = line.match(/^Has\s+key\s+(.+)\s+in\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const k = evaluateValue(m[1].trim()); const o = evaluateValue(m[2].trim());
  variables[m[3]] = !!(o && typeof o==='object' && !Array.isArray(o) && Object.prototype.hasOwnProperty.call(o, k)); return; }
// Keys / Values / Pairs
m = line.match(/^Keys\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const o = evaluateValue(m[1].trim()); if (!o || typeof o!=='object' || Array.isArray(o)) throw new Error('Keys 대상은 Tome이어야 합니다.'); variables[m[2]] = Object.keys(o); return; }
m = line.match(/^Values\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const o = evaluateValue(m[1].trim()); if (!o || typeof o!=='object' || Array.isArray(o)) throw new Error('Values 대상은 Tome이어야 합니다.'); variables[m[2]] = Object.values(o); return; }
m = line.match(/^Pairs\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const o = evaluateValue(m[1].trim()); if (!o || typeof o!=='object' || Array.isArray(o)) throw new Error('Pairs 대상은 Tome이어야 합니다.');
  variables[m[2]] = Object.entries(o); return; }
// Remove key "<k>" from hero
m = line.match(/^Remove\s+key\s+(.+)\s+from\s+(.+)\s*(ok\??|okay\??)$/i);
if (m){ const k = evaluateValue(m[1].trim()); const p = m[2].trim(); const obj = evaluateValue(p);
  if (!obj || typeof obj!=='object' || Array.isArray(obj)) throw new Error('Remove key 대상은 Tome이어야 합니다.'); delete obj[k]; return; }
// Rename key "<old>" to "<new>" in hero
m = line.match(/^Rename\s+key\s+(.+)\s+to\s+(.+)\s+in\s+(.+)\s*(ok\??|okay\??)$/i);
if (m){ const oldK = evaluateValue(m[1].trim()); const newK = evaluateValue(m[2].trim()); const obj = evaluateValue(m[3].trim());
  if (!obj || typeof obj!=='object' || Array.isArray(obj)) throw new Error('Rename key 대상은 Tome이어야 합니다.');
  if (Object.prototype.hasOwnProperty.call(obj, oldK)){ obj[newK] = obj[oldK]; delete obj[oldK]; } return; }
// Merge a into b
m = line.match(/^Merge\s+(.+)\s+into\s+(.+)\s*(ok\??|okay\??)$/i);
if (m){ const src = evaluateValue(m[1].trim()); const dstObj = evaluateValue(m[2].trim());
  if (!src || typeof src!=='object' || Array.isArray(src) || !dstObj || typeof dstObj!=='object' || Array.isArray(dstObj)) throw new Error('Merge 대상은 Tome이어야 합니다.');
  Object.assign(dstObj, src); return; }
// Clone
m = line.match(/^Clone\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const o = evaluateValue(m[1].trim()); variables[m[2]] = JSON.parse(JSON.stringify(o)); return; }
// Pick / Omit
m = line.match(/^Pick\s+keys\s+(.+)\s+from\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const ks = evaluateValue(m[1].trim()); const o = evaluateValue(m[2].trim()); if (!Array.isArray(ks)) throw new Error('Pick keys 인자는 배열이어야 합니다.');
  const out={}; ks.forEach(k=>{ if (o && Object.prototype.hasOwnProperty.call(o, k)) out[k]=o[k]; }); variables[m[3]]=out; return; }
m = line.match(/^Omit\s+keys\s+(.+)\s+from\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const ks = new Set(evaluateValue(m[1].trim())); const o = evaluateValue(m[2].trim()); const out={}; for (const k in o){ if (Object.prototype.hasOwnProperty.call(o,k) && !ks.has(k)) out[k]=o[k]; } variables[m[3]]=out; return; }
// Tally <arr> into <freq>
m = line.match(/^Tally\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a = evaluateValue(m[1].trim()); if (!Array.isArray(a)) throw new Error('Tally 대상은 배열이어야 합니다.');
  const f={}; for (const x of a){ const k = String(x); f[k] = (f[k]||0)+1; } variables[m[2]]=f; return; }

/* ---------- 숫자/수학 ---------- */
m = line.match(/^Modulo\s+(.+)\s+by\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[3]] = Number(evaluateValue(m[1].trim())) % Number(evaluateValue(m[2].trim())); return; }
m = line.match(/^Power\s+(.+)\s+by\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[3]] = Math.pow(Number(evaluateValue(m[1].trim())), Number(evaluateValue(m[2].trim()))); return; }
m = line.match(/^Clamp\s+(.+)\s+between\s+(.+)\s+and\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[4]] = __clamp(Number(evaluateValue(m[1].trim())), Number(evaluateValue(m[2].trim())), Number(evaluateValue(m[3].trim()))); return; }
m = line.match(/^Round\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = Math.round(Number(evaluateValue(m[1].trim()))); return; }
m = line.match(/^Floor\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = Math.floor(Number(evaluateValue(m[1].trim()))); return; }
m = line.match(/^Ceil\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = Math.ceil(Number(evaluateValue(m[1].trim()))); return; }
m = line.match(/^Abs\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = Math.abs(Number(evaluateValue(m[1].trim()))); return; }
m = line.match(/^MapNumber\s+(.+)\s+from\s+(.+)\.\.(.+)\s+to\s+(.+)\.\.(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const x=Number(evaluateValue(m[1].trim())), a1=Number(evaluateValue(m[2].trim())), b1=Number(evaluateValue(m[3].trim())), a2=Number(evaluateValue(m[4].trim())), b2=Number(evaluateValue(m[5].trim()));
  variables[m[6]] = __mapNumber(x,a1,b1,a2,b2); return; }
m = line.match(/^RandomFloat\s+between\s+(.+)\s+and\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a = Number(evaluateValue(m[1].trim())); const b = Number(evaluateValue(m[2].trim())); const lo = Math.min(a,b), hi = Math.max(a,b); variables[m[3]] = __rand()*(hi-lo)+lo; return; }
// alias: Draw float between ...
m = line.match(/^Draw\s+float\s+between\s+(.+)\s+and\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a = Number(evaluateValue(m[1].trim())); const b = Number(evaluateValue(m[2].trim())); const lo = Math.min(a,b), hi = Math.max(a,b); variables[m[3]] = __rand()*(hi-lo)+lo; return; }

/* ---------- 시간 ---------- */
m = line.match(/^NowUTC\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[1]] = new Date(Date.now()); return; }
m = line.match(/^ParseTime\s+"([^"]+)"\s+as\s+"([^"]+)"\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  // 파서는 최소 토큰만 지원(YYYY,MM,DD,HH,mm,ss)
  const [text, fmt, dst] = [m[1], m[2], m[3]];
  const map = { YYYY:0, MM:0, DD:1, HH:0, mm:0, ss:0 };
  const toks = ['YYYY','MM','DD','HH','mm','ss'];
  let re = fmt; toks.forEach(t => re = re.replace(t, `(\\d{${t==='YYYY'?4:2}})`));
  const rx = new RegExp('^' + re + '$'); const ma = text.match(rx);
  if (!ma) throw new Error('ParseTime 실패: 형식이 맞지 않습니다.');
  let idx=1; toks.forEach(t => { const p = fmt.indexOf(t); if (p!==-1){ map[t] = parseInt(ma[idx++],10); }});
  variables[dst] = new Date(map['YYYY']||1970, (map['MM']||1)-1, map['DD']||1, map['HH']||0, map['mm']||0, map['ss']||0);
  return;
}
m = line.match(/^AddDays\s+(.+)\s+by\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const d = new Date(evaluateValue(m[1].trim())); const n = Number(evaluateValue(m[2].trim())); const u = new Date(d); u.setDate(u.getDate()+n); variables[m[3]]=u; return; }
m = line.match(/^AddHours\s+(.+)\s+by\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const d = new Date(evaluateValue(m[1].trim())); const n = Number(evaluateValue(m[2].trim())); const u = new Date(d); u.setHours(u.getHours()+n); variables[m[3]]=u; return; }
m = line.match(/^DiffDays\s+between\s+(.+)\s+and\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a=new Date(evaluateValue(m[1].trim())), b=new Date(evaluateValue(m[2].trim())); variables[m[3]] = Math.round((b-a)/86400000); return; }
m = line.match(/^DiffSeconds\s+between\s+(.+)\s+and\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const a=new Date(evaluateValue(m[1].trim())), b=new Date(evaluateValue(m[2].trim())); variables[m[3]] = Math.round((b-a)/1000); return; }
m = line.match(/^StartOfDay\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const d=new Date(evaluateValue(m[1].trim())); const u=new Date(d); u.setHours(0,0,0,0); variables[m[2]]=u; return; }
m = line.match(/^EndOfDay\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const d=new Date(evaluateValue(m[1].trim())); const u=new Date(d); u.setHours(23,59,59,999); variables[m[2]]=u; return; }

/* ---------- JSON / 타입 / 빈값 ---------- */
m = line.match(/^Encode\s+JSON\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = JSON.stringify(evaluateValue(m[1].trim())); return; }
m = line.match(/^Decode\s+JSON\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const t = String(evaluateValue(m[1].trim())); try{ variables[m[2]] = JSON.parse(t); }catch{ throw new Error('JSON 파싱 실패'); } return; }
m = line.match(/^TypeOf\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const v = evaluateValue(m[1].trim());
  variables[m[2]] = (v===null||v===undefined) ? 'null' : Array.isArray(v)?'array' : (v instanceof Date)?'date' : (typeof v==='object')?'tome':typeof v; return; }
m = line.match(/^IsEmpty\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const v = evaluateValue(m[1].trim()); let f = false;
  if (v==null) f=true; else if (typeof v==='string') f = v.length===0; else if (Array.isArray(v)) f = v.length===0; else if (v instanceof Date) f=false; else if (typeof v==='object') f = Object.keys(v).length===0;
  variables[m[2]] = f; return; }

/* ---------- 확률/선택 ---------- */
m = line.match(/^Choice\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const items = splitTopLevelByComma(m[1].trim()).map(x=>evaluateValue(x)); if (!items.length) throw new Error('Choice 목록이 비었습니다.');
  variables[m[2]] = items[Math.floor(__rand()*items.length)]; return; }
m = line.match(/^Bernoulli\s+with\s+p\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ const p = Number(evaluateValue(m[1].trim())); if (!(p>=0 && p<=1)) throw new Error('p는 0~1이어야 합니다.'); variables[m[2]] = (__rand() < p); return; }
m = line.match(/^Draw\s+from\s+(.+)\s+with\s+weights\s+(.+)\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){
  const arr = evaluateValue(m[1].trim()); const ws = evaluateValue(m[2].trim());
  if (!Array.isArray(arr) || !Array.isArray(ws) || arr.length!==ws.length) throw new Error('가중치 추첨의 길이가 맞지 않습니다.');
  const cum=[]; let s=0; for (const w of ws){ const v=Number(w); if (!(v>=0)) throw new Error('가중치는 0 이상이어야 합니다.'); s+=v; cum.push(s); }
  if (s===0) throw new Error('가중치의 합이 0입니다.');
  const r = __rand()*s; let idx = cum.findIndex(c=>r<c); if (idx<0) idx = arr.length-1; variables[m[3]] = arr[idx]; return;
}

/* ---------- I/O & 디버그 ---------- */
m = line.match(/^Save\s+(.+)\s+as\s+"([^"]+)"\s*(ok\??|okay\??)$/i);
if (m){ __saveAs(evaluateValue(m[1].trim()), m[2]); return; }
m = line.match(/^Copy\s+(.+)\s+to\s+clipboard\s*(ok\??|okay\??)$/i);
if (m){ const val = evaluateValue(m[1].trim()); try{ await __copyToClipboard(val); }catch{} return; }
m = line.match(/^Prompt\s+"(.*)"\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = window.prompt(m[1]) ?? ''; return; }
m = line.match(/^Confirm\s+"(.*)"\s+into\s+(\w+)\s*(ok\??|okay\??)$/i);
if (m){ variables[m[2]] = !!window.confirm(m[1]); return; }
m = line.match(/^Warn:\s*"(.*)"\s*(ok\??|okay\??)?$/i);
if (m){ output += '⚠️ ' + m[1] + '\n'; return; }
m = line.match(/^Assert\s+(.+)\s+with\s+"(.*)"\s*(ok\??|okay\??)$/i);
if (m){ if (!evaluateCondition(m[1].trim())) throw new Error(m[2]); return; }
m = line.match(/^Fail\s+with\s+"(.*)"\s*(ok\??|okay\??)$/i);
if (m){ throw new Error(m[1]); }

    throw new Error('알 수 없는 문장: ' + line);
  }

  // Top-level program
  async function interpret(code){
    const startTime = performance.now();
    const statusIcon = document.querySelector('.status-left i');
    variables = {};
    functionsTable = {};
    constTable = new Set();
    output = '';
    outputConsole.style.color = 'var(--text)';
    statusMessage.textContent = 'Executing...';
    if (statusIcon) statusIcon.className = 'ri-loader-4-line';

    const lines = code.split('\n');
    try {
      for (let i=0; i<lines.length; ){
        let {line:raw, next} = mergeTripleQuote(lines, i);
        const trimmed = raw.trim();
        if (trimmed === '' || trimmed.startsWith('//')) { i = next+1; continue; }

        // inscribe name with a, b:
        let m = trimmed.match(/^inscribe\s+(\w+)\s+with\s*(.*):\s*$/i);
        if (m){
          const name = m[1];
          const params = m[2].trim().length ? m[2].split(',').map(x=>x.trim()) : [];
          const endIdx = findBlockEnd(lines, i);
          if (endIdx === -1) throw new Error("'inscribe' 블록의 'conclude'를 찾을 수 없습니다.");
          const body = lines.slice(i+1, endIdx).join('\n');
          functionsTable[name] = { params, body };
          i = endIdx + 1;
          continue;
        }

        // choose upon VALUE:
        m = trimmed.match(/^choose\s+upon\s+(.+):\s*$/i);
        if (m){
          const keyVal = evaluateValue(m[1].trim());
          const end = findBlockEnd(lines, i);
          if (end === -1) throw new Error("'choose upon' 블록의 'conclude'를 찾을 수 없습니다.");
          let cursor = i + 1;
          let taken = false;
          while (cursor < end){
            const t = lines[cursor].trim();
            const mw = t.match(/^when\s+(.+):\s*$/i);
            if (mw){
              let k = cursor + 1;
              while (k < end){
                const tt = lines[k].trim();
                if (/^when\s+.*:\s*$/i.test(tt) || tt === 'otherwise:') break;
                k++;
              }
              const caseVal = evaluateValue(mw[1].trim());
              if (!taken && caseVal === keyVal) {
                await executeBlock(lines.slice(cursor+1, k).join('\n'));
                taken = true;
              }
              cursor = k; continue;
            }
            if (t === 'otherwise:'){
              if (!taken) await executeBlock(lines.slice(cursor+1, end).join('\n'));
              cursor = end; continue;
            }
            cursor++;
          }
          i = end + 1; continue;
        }

        // when / otherwise when / otherwise
        if (/^when\s+/i.test(trimmed)){
          const mcond = trimmed.match(/^when\s+(.*):$/i);
          if (!mcond) throw new Error("잘못된 'when' 문법입니다.");
          const end = findBlockEnd(lines, i);
          if (end === -1) throw new Error("'when' 블록의 'conclude'를 찾을 수 없습니다.");

          let branches = [];
          let nextB = end;
          for (let k=i+1; k<end; k++){
            const t = lines[k].trim();
            if (/^otherwise\s+when\s+.*:\s*$/i.test(t) || t === 'otherwise:'){ nextB = k; break; }
          }
          branches.push({type:'when', cond:mcond[1].trim(), start:i+1, end:nextB});
          let j = nextB;
          while (j < end){
            const t = lines[j].trim();
            const mm = t.match(/^otherwise\s+when\s+(.*):$/i);
            if (mm){
              let k = j+1;
              while (k<end){
                const u = lines[k].trim();
                if (/^otherwise\s+when\s+.*:\s*$/i.test(u) || u === 'otherwise:') break;
                k++;
              }
              branches.push({type:'elseif', cond:mm[1].trim(), start:j+1, end:k});
              j = k;
            } else break;
          }
          for (let k=j; k<end; k++){
            if (lines[k].trim() === 'otherwise:'){
              branches.push({type:'else', start:k+1, end:end});
              break;
            }
          }
          let taken = false;
          for (const b of branches){
            if (b.type === 'else'){
              if (!taken){ await executeBlock(lines.slice(b.start, b.end).join('\n')); taken = true; }
            } else {
              if (!taken && evaluateCondition(b.cond)){
                await executeBlock(lines.slice(b.start, b.end).join('\n')); taken = true;
              }
            }
          }
          i = end + 1; continue;
        }

        // repeat
        let mrep = trimmed.match(/^repeat\s+(.+)\s+times:\s*$/i);
        if (mrep){
          const n = Number(evaluateValue(mrep[1].trim()));
          const end = findBlockEnd(lines, i);
          if (end === -1) throw new Error("'repeat' 블록의 'conclude'를 찾을 수 없습니다.");
          const body = lines.slice(i+1, end).join('\n');
          for (let k=0;k<Math.max(0,n);k++){
            try { await executeBlock(body); }
            catch (e){
              if (e.__arcana_continue) continue;
              if (e.__arcana_break) break;
              throw e;
            }
          }
          i = end + 1; continue;
        }

        // for each
        let mfe = trimmed.match(/^for\s+each\s+(\w+)\s+in\s+(.+):\s*$/i);
        if (mfe){
          const v = mfe[1];
          const container = evaluateValue(mfe[2].trim());
          const end = findBlockEnd(lines, i);
          if (end === -1) throw new Error("'for each' 블록의 'conclude'를 찾을 수 없습니다.");
          const body = lines.slice(i+1, end).join('\n');
          if (typeof container === 'string'){
            for (const ch of container){
              variables[v] = ch;
              try { await executeBlock(body); }
              catch (e){
                if (e.__arcana_continue) continue;
                if (e.__arcana_break) break;
                throw e;
              }
            }
          } else if (Array.isArray(container)){
            for (const item of container){
              variables[v] = item;
              try { await executeBlock(body); }
              catch (e){
                if (e.__arcana_continue) continue;
                if (e.__arcana_break) break;
                throw e;
              }
            }
          } else { throw new Error("'for each'는 문자열/배열만 순회할 수 있습니다."); }
          i = end + 1; continue;
        }

        // as long as
        let mwl = trimmed.match(/^as\s+long\s+as\s+(.*):\s*$/i);
        if (mwl){
          const condStr = mwl[1].trim();
          const end = findBlockEnd(lines, i);
          if (end === -1) throw new Error("'as long as' 블록의 'conclude'를 찾을 수 없습니다.");
          const body = lines.slice(i+1, end).join('\n');
          let guard=0;
          while (evaluateCondition(condStr)){
            try { await executeBlock(body); }
            catch (e){
              if (e.__arcana_continue) { /* just continue */ }
              else if (e.__arcana_break) break;
              else throw e;
            }
            guard++; if (guard>10000) throw new Error('루프가 너무 깁니다.');
          }
          i = end + 1; continue;
        }

        // Count i from A to B by S:
        let mcnt = trimmed.match(/^Count\s+(\w+)\s+from\s+(.+)\s+to\s+(.+?)(?:\s+by\s+(.+?))?\s*:\s*$/i);
        if (mcnt){
          const varName = mcnt[1];
          const start   = Number(evaluateValue(mcnt[2].trim()));
          const endV    = Number(evaluateValue(mcnt[3].trim()));
          let step      = (mcnt[4] ? Number(evaluateValue(mcnt[4].trim())) : undefined);

          if (!Number.isFinite(start) || !Number.isFinite(endV)) throw new Error('Count의 범위가 유효하지 않습니다.');
          if (step === undefined) step = (start <= endV ? 1 : -1);
          if (!Number.isFinite(step) || step === 0) throw new Error('Count의 step이 유효하지 않습니다.');

          const endIdx = findBlockEnd(lines, i);
          if (endIdx === -1) throw new Error("'Count' 블록의 'conclude'를 찾을 수 없습니다.");
          const body = lines.slice(i+1, endIdx).join('\n');

          if (step > 0){
            for (let v = start; v <= endV; v += step){
              variables[varName] = v;
              try { await executeBlock(body); }
              catch (e){
                if (e.__arcana_continue) continue;
                if (e.__arcana_break) break;
                throw e;
              }
            }
          } else {
            for (let v = start; v >= endV; v += step){
              variables[varName] = v;
              try { await executeBlock(body); }
              catch (e){
                if (e.__arcana_continue) continue;
                if (e.__arcana_break) break;
                throw e;
              }
            }
          }
          i = endIdx + 1;
          continue;
        }

        
        // Attempt / If it fails / Always
        if (/^Attempt\s*:\s*$/i.test(trimmed)){
          const end = findBlockEnd(lines, i);
          if (end === -1) throw new Error("'Attempt' 블록의 'conclude'를 찾을 수 없습니다.");

          const starters = (s)=>/^(when|repeat |for each |as long as|choose upon |inscribe |attempt|count )/i.test(s.trim());
          let depth = 0, catchAt = -1, finallyAt = -1;
          for (let k = i+1; k < end; k++){
            const t = lines[k].trim();
            if (starters(t)) depth++;
            if (t.toLowerCase() === 'conclude') depth--;
            if (depth === 0){
              if (t.toLowerCase() === 'if it fails:') { catchAt = k; }
              else if (t.toLowerCase() === 'always:'){ finallyAt = k; }
            }
          }


          const tryStart   = i+1;
          const tryEnd     = (catchAt !== -1 ? catchAt : (finallyAt !== -1 ? finallyAt : end));
          const catchStart = (catchAt !== -1) ? catchAt + 1 : -1;
          const catchEnd   = (catchAt !== -1) ? ((finallyAt !== -1) ? finallyAt : end) : -1;
          const finStart   = (finallyAt !== -1) ? finallyAt + 1 : -1;
          const finEnd     = (finallyAt !== -1) ? end : -1;

          try {
            await executeBlock(lines.slice(tryStart, tryEnd).join('\n'));
          } catch (e){
            if (e.__arcana_return || e.__arcana_break || e.__arcana_continue) throw e;
            if (catchStart !== -1){
              await executeBlock(lines.slice(catchStart, catchEnd).join('\n'));
            } else {
              throw e;
            }
          } finally {
            if (finStart !== -1){
              await executeBlock(lines.slice(finStart, finEnd).join('\n'));
            }
          }

          i = end + 1;
          continue;
        }

      // Enumerate i, x in <container>:
let men = trimmed.match(/^Enumerate\s+(\w+)\s*,\s*(\w+)\s+in\s+(.+):\s*$/i);
if (men){
  const idxName = men[1], valName = men[2], cont = evaluateValue(men[3].trim());
  const end = findBlockEnd(lines, i); if (end === -1) throw new Error("'Enumerate' 블록의 'conclude'를 찾을 수 없습니다.");
  const body = lines.slice(i+1, end).join('\n');
  if (typeof cont === 'string'){ for (let k=0;k<cont.length;k++){ variables[idxName]=k; variables[valName]=cont[k]; try{ await executeBlock(body);}catch(e){ if(e.__arcana_continue)continue; if(e.__arcana_break)break; throw e; } } }
  else if (Array.isArray(cont)){ for (let k=0;k<cont.length;k++){ variables[idxName]=k; variables[valName]=cont[k]; try{ await executeBlock(body);}catch(e){ if(e.__arcana_continue)continue; if(e.__arcana_break)break; throw e; } } }
  else throw new Error("'Enumerate'는 문자열/배열만 지원합니다.");
  i = end + 1; continue;
}

// for each key k, value v in <tome>:
let mfkv = trimmed.match(/^for\s+each\s+key\s+(\w+)\s*,\s*value\s+(\w+)\s+in\s+(.+):\s*$/i);
if (mfkv){
  const kName = mfkv[1], vName = mfkv[2], obj = evaluateValue(mfkv[3].trim());
  const end = findBlockEnd(lines, i); if (end === -1) throw new Error("'for each key,value' 블록의 'conclude'를 찾을 수 없습니다.");
  const body = lines.slice(i+1, end).join('\n');
  if (!obj || typeof obj!=='object' || Array.isArray(obj)) throw new Error("'for each key,value' 대상은 Tome이어야 합니다.");
  for (const [k,v] of Object.entries(obj)){ variables[kName]=k; variables[vName]=v; try{ await executeBlock(body);}catch(e){ if(e.__arcana_continue)continue; if(e.__arcana_break)break; throw e; } }
  i = end + 1; continue;
}

// Repeat each <x> in <container>:
let mre = trimmed.match(/^Repeat\s+each\s+(\w+)\s+in\s+(.+):\s*$/i);
if (mre){
  const v = mre[1];
  const container = evaluateValue(mre[2].trim());
  const end = findBlockEnd(lines, i);
  if (end === -1) throw new Error("'Repeat each' 블록의 'conclude'를 찾을 수 없습니다.");
  const body = lines.slice(i+1, end).join('\n');

  if (typeof container === 'string'){
    for (const ch of container){ variables[v] = ch; try{ await executeBlock(body); } catch(e){ if(e.__arcana_continue)continue; if(e.__arcana_break)break; else throw e; } }
  } else if (Array.isArray(container)){
    for (const item of container){ variables[v] = item; try{ await executeBlock(body); } catch(e){ if(e.__arcana_continue)continue; if(e.__arcana_break)break; else throw e; } }
  } else throw new Error("'Repeat each'는 문자열/배열만 순회할 수 있습니다.");

  i = end + 1; continue;
}


// until <condition>:
let muntil = trimmed.match(/^until\s+(.*):\s*$/i);
if (muntil){
  const cond = muntil[1].trim();
  const end = findBlockEnd(lines, i); if (end === -1) throw new Error("'until' 블록의 'conclude'를 찾을 수 없습니다.");
  const body = lines.slice(i+1, end).join('\n');
  let guard=0;
  do {
    try{ await executeBlock(body); }catch(e){ if(e.__arcana_continue){} else if(e.__arcana_break) break; else throw e; }
    guard++; if (guard>10000) throw new Error('until 루프가 너무 깁니다.');
  } while (!evaluateCondition(cond));
  i = end + 1; continue;
}

// Guard <cond>: ... otherwise: ... conclude
let mg = trimmed.match(/^Guard\s+(.*):\s*$/i);
if (mg){
  const end = findBlockEnd(lines, i); if (end === -1) throw new Error("'Guard' 블록의 'conclude'를 찾을 수 없습니다.");
  let elseAt = -1, depth=0;
  for (let k=i+1;k<end;k++){
    const t = lines[k].trim();
    if (/^(when|repeat |for each |for each key|as long as|choose upon |inscribe |attempt|count |enumerate |until |guard )/i.test(t)) depth++;
    if (t.toLowerCase()==='conclude') depth--;
    if (depth===0 && t.toLowerCase()==='otherwise:'){ elseAt = k; break; }
  }
  const condOk = evaluateCondition(mg[1].trim());
  if (elseAt === -1){
    if (condOk) await executeBlock(lines.slice(i+1, end).join('\n'));
  } else {
    if (condOk) await executeBlock(lines.slice(i+1, elseAt).join('\n'));
    else        await executeBlock(lines.slice(elseAt+1, end).join('\n'));
  }
  i = end + 1; continue;
}


        // Summon etc. handled in processLine (single-line)
        await processLine(trimmed);
        i = next + 1;
      }

      const duration = Math.round(performance.now() - startTime);
      statusMessage.textContent = `Done (${duration}ms)`;
      const okIcon = document.querySelector('.status-left i');
      if (okIcon) okIcon.className = 'ri-check-double-line';
      outputConsole.textContent = output;

    } catch (err){
      statusMessage.textContent = 'Error';
      const errIcon = document.querySelector('.status-left i');
      if (errIcon) errIcon.className = 'ri-close-circle-line';
      outputConsole.style.color = '#d6b3ff';
      const msg = (err && err.message) ? err.message : String(err);
      outputConsole.textContent = (output ? output + '\n' : '') + '⚠️ ' + msg;
    }
  }

  // Run button
  if (runIcon){
    runIcon.addEventListener('click', async () => { await interpret(codeInputElement.value); });
  }

  // Guide code snippet → editor
  document.querySelectorAll('.code-snippet').forEach(el => {
    el.addEventListener('click', () => {
      const txt = el.innerText || '';
      if (!codeInputElement) return;
      codeInputElement.value = txt;
      updateLineNumbers();
      syncHighlight();
      codeInputElement.focus();
      codeInputElement.setSelectionRange(codeInputElement.value.length, codeInputElement.value.length);
    });
  });
});
